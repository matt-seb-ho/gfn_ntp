{"pairs": [{"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "cases isEmpty_or_nonempty \u03b9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "cases' isEmpty_or_nonempty \u03b9 with h h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "cases' isEmpty_or_nonempty \u03b9 with H\u03b9 H\u03b9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_range', iSup_range']"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "cases' B with B hB"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_range', iSup_range', iSup_eq_iSup_subtype']"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_of_nonempty B, iSup_of_nonempty H]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_eq_iSup, iSup_eq_iSup]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_le_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "cases' B with x hx"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "cases' isEmpty_or_nonempty \u03b9 with H' H'"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_eq_iSup, iSup_eq_iSup, iSup_eq_iSup]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_range', iSup_range', iSup_range']"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "cases' B.eq_empty_or_nonempty with h h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_range', iSup_range', \u2190 Set.range_comp]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_le_iff, iSup_range', iSup_range']"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "cases' Set.eq_empty_or_nonempty (Set.range g) with h h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_le_iff, iSup_range']"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "cases' B with B HB"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup, iSup, iSup, \u2190 Set.range_comp]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_of_nonempty, iSup_of_nonempty]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_range', iSup_range', iSup_eq_iSup]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup, iSup, iSup, iSup, \u2190 Set.range_comp]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "cases' isEmpty_or_nonempty \u03b9 with h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_eq_iSup_subtype, iSup_eq_iSup_subtype, iSup_eq_iSup_subtype]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "cases' B.eq_empty_or_nonempty with hB HB"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_eq_iSup_iff, iSup_eq_iSup_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_range']"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_range', iSup_range', iSup_subtype']"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup, iSup, iSup, \u2190 Set.range_comp, Function.comp]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [\u2190 sSup_range, \u2190 sSup_range]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_range, iSup_range]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_eq_iSup_subtype, iSup_eq_iSup_subtype]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_range', iSup_range', iSup_eq_iSup_subtype]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "simp only [iSup, sSup_le_iff, Set.forall_range_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_range', iSup_range', iSup_eq_iSup_subtype', iSup_eq_iSup_subtype']"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_range', iSup_range', \u2190 iSup_range']"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_range', iSup_range', iSup_eq_iSup_subtype'']"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_range', iSup_range', iSup_range', iSup_eq_iSup_subtype']"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "simp only [iSup, iSup_range', iSup_eq_iSup]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "cases' B.eq_empty_or_nonempty with He Hne"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_eq_iSup_sSup, iSup_eq_iSup_sSup]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup, iSup, iSup, iSup, \u2190 Set.range_comp, Function.comp]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "simp only [iSup, iSup_range, H]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "cases' B with \u27e8c, hc\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "cases' B with x Hx"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_le_iff, iSup_range', \u2190 Set.range_comp]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "cases' isEmpty_or_nonempty \u03b9 with H\u03b9 h\u03b9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_eq_iSup_sSup, iSup_eq_iSup_sSup, iSup_eq_iSup_sSup]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_eq_iSup, iSup_eq_iSup, iSup_eq_iSup, iSup_eq_iSup]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_eq_iSup_iSup, iSup_eq_iSup_iSup]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup, iSup, iSup, iSup_range', \u2190 Set.range_comp]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [\u2190 sSup_range', \u2190 sSup_range']"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_eq_iSup]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_range', iSup_range', iSup_eq_iSup']"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "cases' B with y hy"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup, iSup, iSup, iSup]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_eq_iSup_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "simp only [iSup._eq_1]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "cases' B with \u27e8B, hB\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "simp only [iSup, sSup_range, H]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_eq_iSup_subtype', iSup_eq_iSup_subtype']"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g", "positive": "cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9", "negative": "rw [iSup_eq_iSup', iSup_eq_iSup']"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_of_empty f, iSup_of_empty g]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "simp only [iSup_of_empty, le_rfl]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "simp only [iSup_of_empty', iSup_of_empty']"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_of_empty f, le_rfl]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_of_empty f, iSup_of_empty g, le_rfl]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_of_empty' f, iSup_of_empty' g]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_of_empty f, iSup_of_empty g, iSup_of_empty g]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "simp only [iSup_of_empty]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_of_empty' f, iSup_of_empty g]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "simp only [iSup_of_empty, le_refl]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "rfl"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "simp only [iSup_of_empty, iSup_of_empty']"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [le_rfl, iSup_of_empty f, le_rfl]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "simp only [iSup_of_empty', iSup_of_empty]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_of_empty' f, le_rfl]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "simp only [iSup_of_empty']"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "simp only [iSup_of_empty, iSup_of_empty]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_of_empty' f, iSup_of_empty' g, le_rfl]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [ciSup_of_empty f, ciSup_of_empty g]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [le_rfl, iSup_of_empty' f, le_rfl]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exact le_rfl"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_of_empty' f, iSup_of_empty' g, iSup_of_empty' g]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [ciSup_of_empty' f, ciSup_of_empty' g]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_of_empty f, iSup_of_empty' g]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_le_iSup_of_empty f, iSup_le_iSup_of_empty g]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_of_empty g, iSup_of_empty g]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [le_rfl, iSup_of_empty g]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_of_empty f, iSup_of_empty' g, le_rfl]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_le_iff.2 <| Set.forall_range_iff.2 h\u03b9]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_of_empty' f, iSup_of_empty' g, iSup_of_empty g]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_le_iff.2 fun x => le_rfl, iSup_of_empty g]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_of_empty _, iSup_of_empty _]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_of_empty _, le_rfl]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [ciSup_of_empty f, ciSup_of_empty g, ciSup_of_empty g]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [le_rfl, iSup_le_iSup B H]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [ciSup_of_empty' f, ciSup_of_empty' g, ciSup_of_empty' g]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_of_empty f, iSup_of_empty' g, iSup_of_empty g]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_of_empty' f, iSup_of_empty g, le_rfl]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_of_empty f, iSup_of_empty g, iSup_of_empty' g]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_of_empty', le_rfl]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_of_empty' _, iSup_of_empty' _]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_of_empty' _, le_rfl]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_le_iff.2 fun x => H x, iSup_of_empty g]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [le_rfl, iSup_le_iff.2 H]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_le_iff.2 fun x => le_rfl, le_rfl]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_of_empty' f, iSup_of_empty g, iSup_of_empty g]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [csSup_of_empty' f, csSup_of_empty' g]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [csSup_of_empty f, csSup_of_empty g]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exact iSup_le_iSup_of_empty f"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_of_empty', iSup_of_empty' f, le_rfl]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_le_iff.2 H, iSup_of_empty]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "swap"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_of_empty' _, iSup_of_empty _]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_le_iSup _, iSup_le_iSup _ B]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_le_iSup fun _ => H, iSup_le_iSup g]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_le_iff.2 <| le_rfl, le_rfl]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [le_rfl, iSup_of_empty f, iSup_of_empty g]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [ciSup_of_empty f, ciSup_of_empty' g]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [ciSup_of_empty f, ciSup_of_empty g, ciSup_of_empty' g]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_le_iff.2 <| le_rfl, iSup_of_empty f, le_rfl]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [iSup_le_iSup _ B, iSup_le_iSup _ B]"}, {"state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "simp only [iSup_of_empty', le_rfl]", "negative": "exacts [ciSup_of_empty f, ciSup_of_empty' g, ciSup_of_empty' g]"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun i => iSup_le fun i => H i"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun i => iSup_le H"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le_of_range_subset B H"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_mono H"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun i => le_ciSup B i"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun i => le_iSup_of_le i (H i)"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun i => le_iSup g i"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le H"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun i => iSup_le fun x => H i"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun b => iSup_le H"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun i => le_csSup B i"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun x => iSup_le fun i => H i"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact ciSup_le fun x => le_ciSup B x (H x)"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le_of_range_forall_le B H"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun i => (H i).LE.le.trans (H i)"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun i => iSup_le fun x => H x"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun x => le_iSup_of_le x (H x)"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le_iSup fun i => H i"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact ciSup_le fun x => le_ciSup B x"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact ciSup_le fun i => le_ciSup B i"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun i => iSup_le fun _ => H i"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun x => le_ciSup B x"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun i => Classical.choose_spec (B i)"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun i => le_sSup \u27e8_, H i\u27e9"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun i => iSup_le fun x => H _"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun x => le_iSup_of_le x H"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le_iSup_of_subset B H"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun x => iSup_le H"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun x => le_sSup \u27e8x, H\u27e9"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_mono fun i => H i"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun x => le_csSup B x (H x)"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le_iSup H"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun i => iSup_le fun h => H i"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun x => le_iSup g x"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun x => le_ciSup_of_le B x (H x)"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun i => False.elim (H i)"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun x => le_ciSup B x (H x)"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact ciSup_le fun x => le_ciSup B (H x)"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact ciSup_le H"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun i => h i"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun i => iSup_le fun hi => H i"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun i => le_ciSup_of_le B i"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le_of_surjective B H"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun i => le_ciSup B (H i)"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le_iSup B H"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun i => iSup_le fun h => H _"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun _ => iSup_le H"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun b => iSup_le fun i => H i"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le_iSup_of_surjective B H"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "rw [iSup_range', iSup_range']"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun i => iSup_le_iSup H i"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun i => le_iSup f i"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le_of_surj B H"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun x => le_sSup \u27e8fun i => H i, H i\u27e9"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun i => iSup_le_iSup_of_subset B H"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le_iSup fun x => H x"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_mono fun i => le_iSup_of_le i (H i)"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun x => le_ciSup B (H x)"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun _ => H _"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact ciSup_le fun i => Classical.choose_spec (B i)"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact ciSup_le fun _ => H _"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun i => iSup_le fun hi => H _"}, {"state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u03b9 : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g", "positive": "exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "negative": "exact iSup_le fun i => le_sSup \u27e8i, H\u27e9"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext \u27e8\u27e9"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext <;> simp"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext j"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext \u27e8\u27e8\u27e9\u27e9 <;> dsimp <;> simp"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext \u27e8\u27e8\u27e9\u27e9 <;> dsimp"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "rw [CategoryTheory.Limits.Fork.\u03b9_desc]"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext \u27e8\u27e9 <;> dsimp"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext \u27e8\u27e9 <;> dsimp <;> simp"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext \u27e8\u27e8\u27e9\u27e9 <;> dsimp <;> aesop_cat"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext \u27e8\u27e9 <;> simp"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext n"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext x"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext <;> simp [CategoryTheory.Limits.Fork.\u03b9_desc]"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext d"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "rw [\u2190 CategoryTheory.Limits.BinaryBicone.toCocone_\u03b9_app_right, CategoryTheory.Limits.Fork.app_one_eq_\u03b9_comp_right]"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext a"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext \u27e8\u27e8\u27e9\u27e9"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext (_|n)"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext \u27e8\u27e9 <;> rfl"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext B"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "rw [\u2190 CategoryTheory.Limits.BinaryBicone.toCocone_\u03b9_app_right, CategoryTheory.Limits.Fork.app_one_eq_\u03b9_comp_left]"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "rw [\u2190 CategoryTheory.Limits.BinaryBicone.toCocone_\u03b9_app_right, CategoryTheory.Limits.BinaryBicone.fstKernelFork_\u03b9]"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext <;> simp [CategoryTheory.Limits.Fork.\u03b9_inr]"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "rw [\u2190 CategoryTheory.Limits.BinaryBicone.toCocone_\u03b9_app_left, CategoryTheory.Limits.Fork.app_one_eq_\u03b9_comp_right]"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "rw [\u2190 CategoryTheory.Limits.BinaryBicone.toCocone_\u03b9_app_right]"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext s"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext <;> simp [CategoryTheory.Limits.BinaryBicone.fstKernelFork]"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext \u27e8\u27e8\u27e9\u27e9 <;> rfl"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "rw [\u2190 CategoryTheory.Limits.Fork.condition]"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "rw [\u2190 CategoryTheory.Limits.Fork.condition, CategoryTheory.Limits.Fork.condition]"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext \u27e8\u27e9 <;> dsimp <;> aesop_cat"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "simp"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext B : 2"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext \u27e8\u27e8\u27e9\u27e9 <;> simp"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext \u27e8\u27e9\u27e9 <;> dsimp"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext A"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "rw [\u2190 CategoryTheory.Limits.BinaryBicone.toCocone_\u03b9_app_left, CategoryTheory.Limits.Fork.app_one_eq_\u03b9_comp_left]"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext f"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext X Y"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext : 2"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "funext x"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "rw [\u2190 CategoryTheory.Limits.BinaryBicone.toCocone_\u03b9_app_left, CategoryTheory.Limits.BinaryBicone.fstKernelFork_\u03b9]"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext W"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "rw [\u2190 CategoryTheory.Limits.BinaryBicone.toCocone_\u03b9_app_left]"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "rw [\u2190 CategoryTheory.Limits.BinaryBicone.toCocone_\u03b9_app_right, CategoryTheory.Limits.BinaryBicone.fstKernelFork_\u03b9_app_left]"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext \u27e8\u27e8\u27e9\u27e9 <;> dsimp <;> assumption"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "rw [\u2190 CategoryTheory.Limits.BinaryBicone.toCocone_\u03b9_app_right, CategoryTheory.Limits.BinaryBicone.fstKernelFork_\u03b9_app_right]"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "rw [\u2190 CategoryTheory.Limits.BinaryBicone.toCocone_\u03b9_app_right, CategoryTheory.Limits.BinaryBicone.fstKernelFork_inr]"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext <;> dsimp <;> simp"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "rw [\u2190 CategoryTheory.cancel_epi c.inr]"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext <;> simp [CategoryTheory.Limits.Fork.\u03b9_\u03b9_app_left]"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "rw [\u2190 CategoryTheory.Limits.BinaryBicone.toCocone_\u03b9_app_left, CategoryTheory.Limits.BinaryBicone.fstKernelFork_\u03b9_app_right]"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext i"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext <;> simp [CategoryTheory.Limits.Fork.\u03b9_desc_assoc]"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "rw [CategoryTheory.Limits.Fork.\u03b9_desc_assoc]"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "rw [\u2190 CategoryTheory.Limits.BinaryBicone.toCocone_\u03b9_app_right, CategoryTheory.Limits.Fork.condition]"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "apply CategoryTheory.Limits.Fork.ext"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "rw [\u2190 CategoryTheory.Limits.BinaryBicone.toCocone_\u03b9_app_right, \u2190 CategoryTheory.Limits.BinaryBicone.toCocone_\u03b9_app_right]"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "rw [\u2190 CategoryTheory.Limits.BinaryBicone.toCone_\u03b9_app_right, CategoryTheory.Limits.Fork.app_one_eq_\u03b9_comp_right]"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "rw [\u2190 CategoryTheory.Limits.BinaryBicone.toCocone_\u03b9_app_right c]"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "ext \u27e8\u27e8\u27e9\u27e9 <;> dsimp <;> simp [CategoryTheory.Limits.BinaryBicone.fstKernelFork]"}, {"state": "J : Type w\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasZeroMorphisms C\nP Q X Y : C\nc : BinaryBicone X Y\n\u22a2 Fork.\u03b9 (fstKernelFork c) = c.inr", "positive": "aesop_cat", "negative": "rw [\u2190 CategoryTheory.Limits.BinaryBicone.toCocone_\u03b9_app_right, \u2190 CategoryTheory.Limits.BinaryBicone.toCocone_\u03b9_app_right, CategoryTheory.Limits.BinaryBicone.fstKernelFork_inr]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "simpa [pos_iff_ne_zero] using hs.einfsep"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "simpa [pos_iff_ne_zero] using hs"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "intro x hx"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rcases hs with \u27e8x, hx, y, hy, hxy, hxy'\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "intro x"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rcases hs with \u27e8x, hx\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "lift s to Finset \u03b1 using hs"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rcases hs with \u27e8x, hx, y, hy, hxy, rfl\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "have := hs.toFinset.finite"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rcases hs.einfsep_exists_mem with \u27e8x, hx, y, hy, hxy, hxy'\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "have := hs.toFinset.finite_toSet"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rcases hs.einfsep_subset with \u27e8x, hx, y, hy, hxy, hxy'\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "simpa [pos_iff_ne_zero] using hs.toFinset"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rcases hs.einfsep_exists_of_finite with \u27e8x, hx, y, hy, hxy, hxy'\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "simpa only [pos_iff_ne_zero] using hs.einfsep"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rw [pos_iff_ne_zero]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rcases hs.einfsep_exists_finite with \u27e8x, hx, y, hy, hxy, hxy'\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "nontriviality \u03b1"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "simpa [pos_iff_ne_zero] using hs.toFinset.einfsep"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rcases hs.einfsep_exists_mem with \u27e8x, hx, y, hy, hxy, rfl\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "simpa [pos_iff_ne_zero] using hs.to_subtype"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "simpa [hs.finite_iff] using hs"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rcases hs.einfsep_exists_mem with \u27e8x, _hx, y, _hy, hxy, hxy'\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rcases hs.einfsep_exists with \u27e8x, hx, y, hy, hxy, hxy'\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rcases hs.einfsep_subset_coe_finite with \u27e8x, hx, y, hy, hxy, hxy'\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "inhabit \u03c9\u2080"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "have := hs.to_subtype"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "lift s to Set \u211d\u22650 using hs"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rw [Set.einfsep_pos]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rcases hs.einfsep_subset_below with \u27e8x, hx, y, hy, hxy, hxy'\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rcases hs.einfsep_exists_of_finite with \u27e8x, hx, y, hy, hxy, rfl\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rcases hs.einfsep_exists_finite_subset with \u27e8x, hx, y, hy, hxy, hxy'\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "simpa using hs.einfsep"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "have := hs.toFinset"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rcases hs.einfsep_le with \u27e8x, hx, y, hy, hxy, hxy'\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "simpa [pos_iff_ne_zero, pos_iff_ne_zero] using hs"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rcases hs.einfsep_exists_of_finite with \u27e8x, _hx, y, _hy, hxy, hxy'\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rcases hs.einfsep_subset with \u27e8x, hx, y, hy, hxy, rfl\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rcases hs.einfsep_exists_open with \u27e8x, hx, y, hy, hxy, hxy'\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "intro x _"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "haveI := hs.to_subtype"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "have := hs.toFinset.einfsep"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rcases hs.einfsep_exists_finite with \u27e8x, hx, y, hy, hxy, rfl\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rw [hs.einfsep_zero]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rcases hs.einfsep_subset_coe_finite with \u27e8x, hx, y, hy, hxy, rfl\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "lift s to Set \u03b1 using hs"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "inhabit \u03c9\u2081"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rcases hs.einfsep_subset_coe_finite with \u27e8x, _hx, y, _hy, hxy, hxy'\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rcases hs.einfsep_exists_pos with \u27e8x, hx, y, hy, hxy, hxy'\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "intro x y"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "intro x y hxy"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "simp [Set.einfsep, hs]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rcases hs.einfsep_exists_finite with \u27e8x, _hx, y, _hy, hxy, hxy'\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rcases hs.einfsep_subset_coe_iff.mp hs with \u27e8x, hx, y, hy, hxy, hxy'\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "contrapose! hs"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rcases hs.einfsep_subset_below with \u27e8x, hx, y, hy, hxy, rfl\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rcases hs.einfsep_subset with \u27e8x, _hx, y, _hy, hxy, hxy'\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rcases hs.einfsep_exists_pos with \u27e8x, _hx, y, _hy, hxy, hxy'\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "simp [hs.einfsep_zero]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "simpa [pos_iff_ne_zero] using Set.einfsep_pos.1 hs"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "simp [Set.einfsep_pos, hs]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rcases hs.einfsep_subset_below with \u27e8x, _hx, y, _hy, hxy, hxy'\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\nhs : Set.Finite s\n\u22a2 0 < Set.einfsep s", "positive": "cases hs", "negative": "rcases hs.einfsep_subset_compl with \u27e8x, hx, y, hy, hxy, hxy'\u27e9"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "exact Set.einfsep_pos"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "by_contra h"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "exact Set.einfsep_pos.2"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "simpa [pos_iff_ne_zero] using Set.einfsep_pos"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "exact Set.einfsep_pos_of_finite s"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "exact Set.einfsep_pos.2 (by simp)"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "simpa [pos_iff_ne_zero] using ENNReal.einfsep_pos"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "rcases ENNReal.exists_nat_gt (0 : \u211d\u22650\u221e) with \u27e8C, hC\u27e9"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "simp_rw [Set.einfsep, iInf_pos]"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "exact ENNReal.zero_lt_top"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "rcases ENNReal.exists_nat_gt (0 : \u211d\u22650\u221e) with \u27e8n, hn\u27e9"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "simp only [pos_iff_ne_zero, Set.einfsep_zero]"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "simp_rw [pos_iff_ne_zero]"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "simp only [Set.einfsep, iInf_pos]"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "exact zero_lt_one"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "simp [Set.einfsep_pos]"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "rcases s.eq_empty_or_nonempty with (rfl | hs)"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "simp_rw [Set.einfsep_pos]"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "rcases ENNReal.exists_nat_gt (0 : \u211d\u22650\u221e) with \u27e8C, _hC\u2080, hC\u27e9"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "by_cases hs : s.Nontrivial"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "exact ENNReal.zero_lt_one"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "inhabit s"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "simp [Set.einfsep]"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "exact ENNReal.pos_top"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "simp_rw [pos_iff_ne_zero, Set.einfsep_zero]"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "simp only [pos_iff_ne_zero, Set.einfsep_pos]"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "rcases ENNReal.exists_nnreal_pos_mul_lt ENNReal.two_ne_top with \u27e8n, hn\u27e9"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "rcases s.eq_empty_or_nonempty with (rfl | h)"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "rcases ENNReal.exists_nat_gt (\u03b1 := \u211d\u22650\u221e) with \u27e8C, hC\u27e9"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "rcases ENNReal.exists_nat_gt (0 : \u211d\u22650\u221e) with \u27e8c, hc\u27e9"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "simpa using ENNReal.einfsep_pos"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "by_contra H"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "rw [pos_iff_ne_zero]"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "simp [Set.einfsep, pos_iff_ne_zero]"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "simp only [Set.einfsep_pos, pos_iff_ne_zero]"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "rcases s.einfsep_exists_pos with \u27e8x, _hx, y, _hy, hxy, hxy'\u27e9"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "exact Set.einfsep_pos s"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "exact Set.einfsep_pos.2 (by simpa)"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "simp only [gt_iff_lt, Set.einfsep_pos]"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "rcases ENNReal.exists_nnreal_pos_mul_lt ENNReal.two_ne_top with \u27e8C, _hC\u2080, hC\u27e9"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "exact Set.einfsep_pos_to_finite"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "exact Set.einfsep_pos.2 \u27e81, one_pos, by simp\u27e9"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "simpa [pos_iff_ne_zero] using Set.einfsep_pos_of_finite s"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "rcases s.eq_empty_or_nonempty with rfl | \u27e8x, hx\u27e9"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "rw [Set.einfsep_pos]"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "rcases s.eq_empty_or_nonempty with rfl | hs"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "rcases ENNReal.exists_nnreal_pos_mul_lt ENNReal.coe_ne_top with \u27e8n, hn\u27e9"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "simp"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "simp [pos_iff_ne_zero, Set.einfsep]"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "rcases ENNReal.exists_nat_gt (\u03b1 := \u211d\u22650\u221e) with \u27e8C, _hC\u2080, hC\u27e9"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "contrapose! hC"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "simp_rw [pos_iff_ne_zero, Set.einfsep_pos]"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "by_contra' h"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "exact Set.einfsep_pos.2 \u27e81, zero_lt_one, by simp\u27e9"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "rcases s.einfsep_exists_finset with \u27e8x, _hx, y, _hy, hxy, hxy'\u27e9"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "exact ENNReal.pos_iff_ne_zero.2 (pos_iff_ne_zero.2 ENNReal.two_ne_top)"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "simpa [pos_iff_ne_zero] using ENNReal.einfsep_pos_of_finite"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "rcases ENNReal.exists_nat_gt (0 : \u211d\u22650\u221e) with \u27e8C, hC\u2080, hC\u27e9"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "simpa [pos_iff_ne_zero] using ENNReal.einfsep_pos_of_finite s"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "rcases ENNReal.exists_nat_gt (\u03b1 := \u211d\u22650\u221e) with \u27e8n, hn\u27e9"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "rcases s.einfsep_exists_of_finite with \u27e8x, _hx, y, _hy, hxy, hxy'\u27e9"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "rcases ENNReal.exists_nnreal_pos_mul_lt ENNReal.two_ne_top with \u27e8C, hC\u27e9"}, {"state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nC : \u211d\u22650\u221e\nsC : Set \u211d\u22650\u221e\na\u271d : Fintype \u2191s\n\u22a2 0 < Set.einfsep s", "positive": "exact Set.einfsep_pos_of_finite", "negative": "simp [ENNReal.lt_iff_exists_nnreal_btwn, pos_iff_ne_zero]"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "simp"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact h\u2082 x"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact ContinuousLinearMap.map_smul _ _ _"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "apply ContinuousLinearMap.ext_ring"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "apply mul_right_cancel"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "rw [ContinuousLinearMap.equivOfInverse_apply]"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "apply ContinuousMap.coe_injective"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "apply ContinuousMap.equivOfInverse_apply"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "rw [ContinuousMap.equivOfInverse_apply]"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "apply (h\u2081 x).Eq.symm"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact (h\u2082 x).Eq.symm"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact ContinuousLinearMap.map_zero _"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact ContinuousLinearMap.coe_mk _ _"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact ContinuousMap.congr_fun (h\u2081 x) x"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact ContinuousMap.coe_mk _ _"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "apply ContinuousMap.coe_mk"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "apply (f\u2081 x).ContinuousLinearMap.ext_ring"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact ContinuousLinearMap.equivOfInverse_apply h\u2081 h\u2082 x"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact ContinuousMap.congr_fun h\u2081 h\u2082 x"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "apply ContinuousMap.ext_ring"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact mul_one _"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "apply Pi.smul_apply"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact (h\u2081 x).Eq.symm"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact ContinuousMap.congr_fun h\u2082 x"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact ContinuousLinearMap.equivOfInverse_apply _ _ _ _"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "apply ContinuousLinearMap.equivOfInverse_apply"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "apply h\u2082"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact ContinuousLinearMap.equivOfInverse_apply h\u2081 h\u2082 (x := x)"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "apply mul_one"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "apply ContinuousLinearMap.map_smul"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "apply mul_right_cancel\u2080 (h\u2082 x)"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact ContinuousLinearMap.equivOfInverse_apply h\u2082 _ _"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact ContinuousMap.congr_fun h\u2081 x x"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact ContinuousLinearMap.coe_coe _ _"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "apply Prod.ext"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact ContinuousMap.congr_fun (h\u2082 x) x"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact ContinuousLinearMap.coe_comp' _ _"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "apply ContinuousMap.congr_fun h\u2081"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "apply MulOpposite.op_injective"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact h\u2082 _ x"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact ContinuousMap.coe_mulOfInverse _ _ _"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact ContinuousLinearMap.map_smul\u209b\u2097 _ _ _ _"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact ContinuousMap.coe_mk _ _ _"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "apply Units.ext_iff.2"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact ContinuousMap.congr_fun h\u2081 x"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact ContinuousLinearMap.map_smul_of_tower _ _ _"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "rw [ContinuousLinearMap.equivOfInverse, dif_pos (h\u2081 x)]"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact ContinuousLinearMap.equivOfInverse_apply _ _ _"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "apply ContinuousMap.congr_fun"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "apply Pi.single_apply"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact ContinuousMap.congr_fun h\u2082 x x"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "apply ContinuousLinearMap.ext_ringHom"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "apply Pi.eq_symm_apply"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "apply ContinuousLinearMap.coe_injective"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "apply smul_eq_mul"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact ContinuousLinearMap.op_smul_eq_smul _ _ _"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact mul_comm _ _"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact ContinuousLinearMap.coe_coe _"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "apply mul_right_cancel\u2080 (h\u2081 x)"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact h\u2081 x"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "apply Pi.eq"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "exact ContinuousMap.map_smul _ _ _"}, {"state": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b2\u2074 : Semiring R\u2081\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\ninst\u271d\u00b2\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2\u2070 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\ninst\u271d\u00b9\u2079 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b9\u2078 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u00b9\u2077 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\ninst\u271d\u00b9\u2076 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b3 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u00b9 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R\u2081 M\u2081\ninst\u271d\u00b2 : Module R\u2081 M'\u2081\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : Module R\u2083 M\u2083\nf\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081\nh\u2081 : Function.LeftInverse \u2191f\u2082 \u2191f\u2081\nh\u2082 : Function.RightInverse \u2191f\u2082 \u2191f\u2081\nx : M\u2081\n\u22a2 \u2191(equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082) x = \u2191f\u2081 x", "positive": "rfl", "negative": "rw [ContinuousLinearMap.equivOfInverse, ContinuousLinearMap.coe_mk, h\u2081 x, h\u2082 x]"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_pos_left hm hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_right hm hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_left hm hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_self_lt_mul_self hm hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_pos_left hn hm"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_pos_right hm (le_of_lt hn)"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul hm hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_pos_of_left hm hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_pos_right hn hm"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_pos_left hm (le_of_lt hn)"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_pos_right hm (le_of_lt hn) hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_pos_left hm (le_of_lt hn) hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_left' hm hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_neg_right hm hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul hm hn using 1 <;> simp"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul'' hm hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_neg_left hm hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_self_lt_mul_self hn hm"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul' hm hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_pos_right (mul_pos hn hm) hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_left' hm a"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_pos_right hm (lt_of_lt_of_le zero_le_one hn)"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_right hn hm"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert (mul_lt_mul_left hm).2 hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_pos_left hm zero_le_one hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_pos_left hm (lt_of_lt_of_le zero_le_one hn)"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_pos_of_lt hm hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_left hm a"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_pos_left (mul_pos hn hm) hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert (mul_lt_mul_left hm).Iff.mpr hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_pos_right hm zero_le_one hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_right_lt_mul_self hm hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_right' hm hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_pos_right hm (lt_of_lt_of_le zero_lt_one hn)"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_pos_left hm (lt_of_lt_of_le zero_le' hn)"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_pos_left hm (lt_of_lt_of_le zero_lt_one hn)"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert lt_mul_of_one_lt_right hm hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_pos_right hm (lt_of_lt_of_le zero_le' hn)"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_right_lt_mul_right hm hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_pos_left hm (lt_of_lt_of_le zero_le' hn) hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_left hn hm"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_right hm a"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert lt_mul_of_one_lt_left hm hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_pos_right hm (lt_of_lt_of_le zero_le_one hn) hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul\u2080 hm hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul' hm hn using 1 <;> simp"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_lt_of_le hm hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_pos_left hm (lt_of_lt_of_le zero_le_one hn) hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert (mul_lt_mul_left hn).2 hm using 1"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_lt_of_pos hm hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_left hm hn using 1 <;> simp"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_pos_right hm (zero_le a)"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_pos_left hm (mul_pos hn hm) using 1"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_pos_right hm (lt_of_lt_of_le zero_le' hn) hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert lt_mul_of_one_lt_right' hm hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_left hm (le_of_lt hn) hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_pos_left hm (zero_le _) hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_pos_right hm (zero_le _) hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_pos_of_lt_left hm hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_pos_left hm (zero_le a)"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_of_nonneg_left hm hn"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_right_comm.2 hm"}, {"state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a < b * a", "positive": "convert mul_lt_mul_of_pos_right hm hn", "negative": "convert mul_lt_mul_right hm hn using 1 <;> simp"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rwa [one_mul]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "exact (one_mul _).Eq.symm"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "exact (one_mul a).Eq.symm"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rw"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rw [one_mul, mul_one]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rw [mul_one]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rw_mod_cast [mul_one]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rwo [one_mul]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rw [one_mul hn]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rw [one_mul, mul_one a]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rw [one_mul, hm.le]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rw [one_mul a, mul_one]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rw one_mul hn]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rw_mod_cast [mul_one a]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rwo[one_mul]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rwy [one_mul]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rw one_mul]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rw one_mul a]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rw one_mul a"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rww [one_mul]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rw [mul_one a]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rw.symm]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "conv_rhs => rw [\u2190 mul_one a]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rwa [one_mul a]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rw [one_mul a, one_mul]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rW [one_mul]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rwu[one_mul]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rw [one_mul, hn.le]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rw [one_mul, one_mul]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rw [one_mul a, mul_one a]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rw [one_mul, hn]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rwA [one_mul]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "norm_cast"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rw* one_mul]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rw [one_mul, hn.ne']"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "conv_rhs => rw [mul_one]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rwrity"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rw* one_mul a"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rwulog one_mul a"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rw1 [one_mul]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rw one_mul _]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "norm_num"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rwritten rw [one_mul]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "exact (mul_one _).Eq.symm"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rwr[one_mul]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "exact (one_mul hn).Eq.symm"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "conv_rhs => rw [\u2190 one_mul a]"}, {"state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : StrictOrderedSemiring \u03b1\na b c d : \u03b1\nhn : 0 < a\nhm : 1 < b\n\u22a2 a = 1 * a", "positive": "rw [one_mul]", "negative": "rw [one_mul hm]"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases b <;> decide"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a <;> Decide"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a with cases a <;> decide"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a with simp"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases A <;> decide"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a <;> exact Bool.decide_false"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a <;> decide (a = Bool.true)"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a with s; simp"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a <;> Decidable"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a <;> Decidable.decEq (a = Bool.true)"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a with s; cases h <;> decide"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a with s; cases b <;> decide"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a with s; cases a <;> decide"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases oa <;> decide"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases Bool.false <;> decide"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases.a <;> decide"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a <;> cases b <;> decide"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a >;> decide"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a <;> Decidable.decEq (a = false)"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "contradiction"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a <;> Decidable (a = Bool.true)"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a <;> Decidable.decide (a = Bool.true)"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a <;> decide (a = false)"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases o <;> decide"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a <;> Decidable.decide (a = Bool.true) <;> decide"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a <;> Decidable.decide"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases of Bool.true = Bool.true <;> decide"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases of Bool.true = Bool.true"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a <;> Decidable.decEq <;> decide"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "contrapose!"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases false <;> decide"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a <;> Decidable.decEq (a = 0) <;> decide"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a <;> exact Bool.false_eq_true"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases of Bool.true <;> decide"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases Bool.true <;> decide"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a <;> Decidable b"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a <;> Decidable.decide (a = false)"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a <;> Decidable.decEq (a = Bool.true) <;> decide"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "contrapose"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a with s <;> decide"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a <;> decide (a = Bool.false)"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a with c; cases h <;> decide"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a with c <;> decide"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a <;> Decidable h"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a <;> intro h <;> cases h"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "change Decidable.decide (a = Bool.true) = _"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a <;> intro h <;> decide"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a <;> decide (a = Bool.true) = Bool.true"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases m <;> decide"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a with s; cases h"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a; decide"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a; exact Bool.decide_false"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a <;> Decidable "}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a <;> Decidable.decide (a = false) <;> decide"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a <;> Decidable Bool.false"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a <;> Decidable Bool.true = Bool.true"}, {"state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true", "positive": "cases a <;> decide", "negative": "cases a <;> intro h"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "intro x"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "intro"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "intro s"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "intro e"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "intro i"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "intro y"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "intro b"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8a\u2081, b\u2081\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "intro f"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8\u27e8x, y\u27e9, h\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "apply Function.surjective_of_right_cancellable_Prop"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8a\u2081, a\u2082\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8\u27e8x\u27e9, hx\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8x\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "intros"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "apply Function.surjective_up"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8\u27e8f, _\u27e9, _\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "intro c"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8x, y\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8x\u2081, x\u2082\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8\u27e8\u27e9\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "intros x"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8a, ha\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8\u27e8a, b\u27e9, h\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "intro a"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "intro S"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8x, hx\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8\u27e8x, y\u27e9, hx\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "intro t"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8x, x\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8\u27e8x\u27e9, h\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8\u27e8f, hf\u27e9\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8\u27e8x\u27e9\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8a\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8a\u2081, b\u2082\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8a, e\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8a, rfl\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8\u27e8x, y\u27e9\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8\u27e8f, _\u27e9\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "intro d"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8\u27e8\u27e9, _\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8\u27e8a, b\u27e9\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "introv"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8x, rfl\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "apply Function.surjective_id"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8\u27e8x\u27e9, x\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "apply surjective_up"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "apply Subtype.rec"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "intro r"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "apply Subsingleton.elim"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8\u27e8a\u27e9, h\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8b\u2081, hb\u2081\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8\u27e8x\u27e9, y\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8\u27e8a, f\u27e9\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "apply Subtype.range_coe"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8\u27e8a\u2081, a\u2082\u27e9, \u27e8b\u2081, b\u2082\u27e9\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8\u27e8x, y\u27e9, h\u2081\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8\u27e8x, h1\u27e9, h2\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8x, x'\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8\u27e8x, y\u27e9, rfl\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "rintro \u27e8\u27e8x\u2081, x\u2082\u27e9, h\u27e9"}, {"state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u22a2 Surjective up", "positive": "intro <;> simp", "negative": "intro T"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "unfold derivWithin"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "unfold derivWithin derivWithin"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "unfold derivWithin derivWithin derivWithin"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "simp [derivWithin, hs.fderivWithin hx]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "subst x"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "dsimp only [derivWithin]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "unfold derivWithin derivWithin derivWithin derivWithin"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "simp only [derivWithin, hs.fderivWithin hx]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "simp only [derivWithin, fderivWithin_congr hs hx, hs hx]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "simp [derivWithin, hs hx]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "unfold derivWithin fderivWithin"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "simp only [derivWithin, hs hx]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "unfold derivWithin DifferentiableWithinAt"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "simp [derivWithin, hs.fderivWithin_eq hx]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "unfold DerivWithin"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "simp only [derivWithin, derivWithin_congr hs hx]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "simp [derivWithin, *]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "simp only [derivWithin, fderivWithin, hs hx]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "unfold derivWithin at hs \u22a2"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "simp only [derivWithin]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "dsimp [derivWithin]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "induction' s with y IH"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "simp only [derivWithin, fderivWithin, hs.fderivWithin hx]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "simp only [derivWithin, hasFDerivWithinAt_congr hs hx]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "simp [derivWithin, hs, hx]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "simp only [derivWithin, fderivWithin_congr, hs hx]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "simp only [derivWithin, *]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "induction' s with y L ih"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "unfold derivWithin derivWithin fderivWithin"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "unfold derivWithin DifferentiableWithinAt.derivWithin"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "simp only [derivWithin, if_pos hs, hx]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "simp only [derivWithin, hs.fderivWithin_eq hx]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "unfold derivWithin at *"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "suffices derivWithin f s x = derivWithin f s x by simp only [derivWithin, fderivWithin_congr hs hx]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "simp only [derivWithin, hasDerivWithinAt_congr hs hx]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "induction x using WithTop.recTopCoe"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "suffices derivWithin f s x = derivWithin f s x by simp only [derivWithin, hs hx]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "simp only [derivWithin, fderivWithin_congr' hs hx]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "simp only [derivWithin, fderivWithin_congr hs hx, derivWithin_congr hx]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "unfold derivWithin DifferentiableWithinAt.fderivWithin"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "simp [derivWithin, derivWithin_congr hs hx]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "unfold derivWithin at hx \u22a2"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "unfold DerivWithin derivWithin"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "rw [derivWithin, fderivWithin_congr hs hx]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "simp only [derivWithin, derivWithin, hs hx]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "unfold derivWithin DifferentiableWithinAt derivWithin"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "simp only [derivWithin, mfld_simps]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "simp only [derivWithin, if_pos hs, if_pos hx]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "induction' s using WithTop.recTopCoe with l L"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "simp [derivWithin, hasFDerivWithinAt_congr hs hx]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "suffices derivWithin f s x = derivWithin f s x by simp only [derivWithin, fderivWithin_congr this hx]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "induction' s with y L ihL"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "simp only [derivWithin, hfderivWithin_congr hs hx]"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "unfold_let derivWithin"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "unfold derivWithin at hx"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "unfold derivWithin derivWithin Filter.derivWithin"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "unfold derivWithin IsometryEquiv.derivWithin"}, {"state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "positive": "simp only [derivWithin, fderivWithin_congr hs hx]", "negative": "induction' s using WithTop.recTopCoe with a"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (x : \u211d)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (-x)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (InfinitePos.pos hip)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (by assumption)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (by decide)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (InfinitePos.ne_zero hip)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (by exact_mod_cast hip _)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (InfinitePos.ne_zero x)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (x - 0)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (InfinitePos.neg x)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (InfinitePos.prod hip)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (by norm_num)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (InfinitePos.ne_one x)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (ne_of_gt (hip 0))"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (-1)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (x := x)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip.pos"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (not_lt.mpr hip)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (InfinitePos.pos x)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip x"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (ne_of_gt hip)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (dvd_refl _)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "by_contra h"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip 1"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact Real.pi_pos"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (x - 1)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (inv_nonneg.2 hip.nonneg)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (by decide : (0 : \u211d) < 0)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (by exact_mod_cast hip.pos)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (n := 0)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (by exact_mod_cast hip 0)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (neg_nonpos.mpr hip.ne_zero)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (InfinitePos.pos hip).LT.lt.ne'"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (neg_ne_zero.mpr hip)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (InfinitePos.ne_zero 0)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (x + 1)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (lt_of_lt_of_le zero_lt_one hip)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (ne_of_gt zero_lt_one)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (InfinitePos.prod_ne_zero hip)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (InfinitePos.prod_neg hip)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (InfinitePos.pos _)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (ne_of_gt (hip (x - 1)))"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (InfinitePos.prop _)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (InfinitePos.zero_lt_one x)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (InfinitePos.ne_of_infinitePos hip)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (ne_of_gt (hip _))"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (dist_pos.mpr hip)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (InfinitePos.prod_nonneg hip)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (dvd_refl 0)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (by decide : (0 : \u211d) < 1)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (InfinitePos.prod x)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (lt_add_one _)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (ne_of_gt (hip (x := x)))"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact (hip (-x)).LT.lt.trans_le zero_lt_one"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (ne_of_gt (inv_pos.2 hip))"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (InfinitePos.zero : x \u2260 0)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (inv_ne_zero Real.pi_pos)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (InfinitePos.prod_pos hip)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (dist_nonneg.mpr hip.nonneg)"}, {"state": "x : \u211d*\nhip : InfinitePos x\n\u22a2 0 < x", "positive": "exact hip _", "negative": "exact hip (InfinitePos.ne_of_infinitePos x)"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [Set.EqOn] at hg \u22a2"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [Set.EqOn]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [Set.eqOn_comp]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "intro y hy"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [Set.EqOn] at hg"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [Set.EqOn] at hf \u22a2"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "intro a ha"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [Set.EqOn] at *"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "intro b hb"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [Set.eqOn_eqOn] at hg \u22a2"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [Set.EqOn, Set.ball_image_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [Set.eqOn_comp] at hg \u22a2"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [\u2190 Set.EqOn] at hg \u22a2"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rwa [Set.EqOn, Set.eqOn_comp]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "intro _ hx"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rwa [Set.eqOn_comp]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [Set.eqOn_eqOn_iff] at hg \u22a2"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rwa [Set.EqOn, Set.ball_image_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [\u2190 Set.ball_image_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [\u2190 Set.ball_image_iff] at hg \u22a2"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [\u2190 Set.eqOn_comp]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "intro x xs"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [\u2190 Set.EqOn] at hf \u22a2"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [Set.EqOn, Function.comp]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [Set.eqOn_iff_inter_eq_empty] at hg \u22a2"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [Set.EqOn, Set.ball_image_iff] at hg \u22a2"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [Set.EqOn, Set.eqOn_comp]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [Set.eqOn_eqOn] at hf \u22a2"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [\u2190 Set.eqOn_comp] at hg \u22a2"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [\u2190Set.EqOn] at hg \u22a2"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rintro x \u27e8x, hx, rfl\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [Set.eqOn_eqOn_iff_mapsTo] at hg \u22a2"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [Set.EqOn] at hg hf \u22a2"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rintro _ \u27e8x, hx, rfl\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [\u2190 Set.eqOn_refl] at hg \u22a2"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [\u2190Set.ball_image_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rwa [Set.EqOn, Set.eqOn_comp hg]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [Set.eqOn_eqOn] at *"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "intro p hp"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [Set.eqOn_eqOn]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [\u2190Set.ball_image_iff] at hg \u22a2"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rintro a ha"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "intro x hx y hy"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [Set.eqOn_iff_forall_not_mem] at hg \u22a2"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rwa [Set.EqOn, \u2190 Set.eqOn_comp]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [Set.EqOn, Set.mapsTo_image]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [Set.eqOn_eqOn_iff_eqOn] at hg \u22a2"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [Set.eqOn_comp] at *"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [Set.EqOn, Function.comp_apply]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [Set.eqOn_comp] at hg"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "intro _ ha"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [Set.eqOn_comp] at hf \u22a2"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [\u2190 Set.biUnion_of_singleton hg]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [\u2190 Set.eqOn_eqOn] at hg \u22a2"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [Set.eqOn_refl] at hg \u22a2"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rwa [Set.EqOn, Set.eqOn_empty]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [\u2190 Set.EqOn] at hg"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [\u2190 Set.maps_univ_eq_image]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [\u2190 Set.preimage_comp]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rwa [Set.EqOn, Set.eqOn_comp hf]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rw [Set.EqOn] at hf hg \u22a2"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\n\u22a2 EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s", "positive": "intro x hx", "negative": "rintro _ \u27e8a, ha, rfl\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp, hg hx]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp_apply, hg hx]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp, hg hx, hg (hf hx)]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp, hg (hf hx), hg hx]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp [hg hx]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp, hg _]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [hg hx, hg (hf hx)]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp_apply, hg hx, hg (hf hx)]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp, hg hx, Function.comp_apply]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [hg hx, Function.comp_apply]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [hg (hf hx), hg (hf hx)]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp, hg hx, hg hx]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp, hg _, hg hx]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp, hg, hf hx]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp_apply, hg _]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp_apply, hg (hf hx), hg hx]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp [hf hx]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp, hg hx, Function.comp.left_id]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "rw [Function.comp_apply, hg (hf hx), hg (hf hx)]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp_apply]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp, hg (hf hx), hg (hg hx)]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [hg hx, hg (hf hx), Function.comp_apply]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "rw [Function.comp, hg (hf hx), hg (hf hx)]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp, hg hx, congr_fun hg (hf hx)]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp, hg hx, hg _]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp, hg hx, congr_fun hg _]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp, hg hx, congr_fun (hg hx)]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp, hg, hf]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp, hg, hf _]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp_apply, hg hx, hg hx]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "rw [Function.comp_apply, hg hx, hg (hf hx)]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp, hg (hf hx), hg.eq_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp, hg hx, Function.comp]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp, hg hx, congr_fun (hf hx)]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "rw [Function.comp_apply, hg (hf hx)]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp, hg, hf (hf hx)]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simpa only [Function.comp_apply] using hg (hf hx)"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [hg _, hg hx]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [hg hx, hg hx]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp, hg hx, hf (hf hx)]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp, hg (hf hx), h hx]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp, hg hx, Function.comp.right_id]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp, hg _, hf _]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp_apply, hg hx, comp_eq_id]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp, hg hx, Function.comp.assoc]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp, hg hx, congr_arg Function.comp]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp_apply, hg _, hg hx]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "exact hg hx"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp, hg (hf hx), hh (hf hx)]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [hg _, hg (hf hx)]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp, hg hx, congr_fun hg]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhg : EqOn g\u2081 g\u2082 t\nhf : MapsTo f s t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (g\u2081 \u2218 f) x = (g\u2082 \u2218 f) x", "positive": "simp only [Function.comp, hg (hf hx), hg (hf hx)]", "negative": "simp only [Function.comp, hg (hf hx), hg (ht hx)]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "simp"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "simp [mul_comm]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "show ite _ _ _ = _"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "rw [mul_comm, LinearMap.mulRight_apply]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "show IsScalarTower R A A = b * a"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "simp [LinearMap.mulRight_apply]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "rw [\u2190 mul_one b, LinearMap.mulRight_apply]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "symm"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "show mul_comm _ _ = _"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "rw [LinearMap.mulRight_apply, mul_comm]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "show ite _ _ _ * ite _ _ _ = _"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "show IsScalarTower R A A A = b * a"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "rw [\u2190 mul_one a, LinearMap.mulRight_apply]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "rw [\u2190 mul_one a, LinearMap.mulRight_apply, mul_comm]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "rw [\u2190 smul_eq_mul, LinearMap.mulRight_apply, mul_comm]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "rw [\u2190 mul_one b, LinearMap.mulRight_apply, mul_comm]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "rw [\u2190 IsScalarTower.assoc, LinearMap.mulRight_apply, mul_comm]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "simp only [mul_comm, LinearMap.mulRight_apply]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "rw [\u2190 smul_eq_mul, LinearMap.mulRight_apply]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "show apply (LinearMap.mulRight R a) b = _"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "show LinearMap.mulRight R a b = b * a"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "show IsScalarTower R A A := { carrier := { carrier := smul_assoc a b }"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "rw [\u2190 smul_eq_mul, LinearMap.mulRight_apply, smul_eq_mul]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "rw [\u2190 one_mul a, LinearMap.mulRight_apply]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "suffices : (LinearMap.mulRight R a b : A) = b * a"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "show mul _ _ _ = _"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "show Units.mk0 _ _ = _"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "apply mul_comm"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "simp [mul_comm, LinearMap.mulRight_apply]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "show IsScalarTower R A A := { carrier := { carrier := smul_eq_mul R a b }"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "rw [\u2190 smul_eq_mul, LinearMap.mulRight_apply, one_mul]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "rw [LinearMap.mulRight_apply, smul_eq_mul, mul_comm]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "rw [\u2190 mul_one a, LinearMap.mulRight_apply, one_mul]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "show Units.ext _ = _"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "show smul _ _ _ = _"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "rw [\u2190 mul_one b, LinearMap.mulRight_apply, smul_eq_mul]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "rw [\u2190 IsScalarTower.algebraMap_smul R a b, LinearMap.mulRight_apply]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "suffices : a * (b * a) = b * a"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "show (LinearMap.mulRight R a b : A) = b * a"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "rw [\u2190 mul_one a, LinearMap.mulRight_apply, smul_eq_mul]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "apply LinearMap.mulRight_apply"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "rw [\u2190 IsScalarTower.algebraMap_smul, LinearMap.mulRight_apply]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "rw [\u2190 smul_eq_mul, \u2190 mul_assoc, LinearMap.mulRight_apply]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "show IsScalarTower R A A := { carrier := smul_assoc _ _ _ }"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "show _ * _ = _"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "rw [\u2190 IsScalarTower.assoc, LinearMap.mulRight_apply, smul_eq_mul]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "rw [\u2190 one_mul a, LinearMap.mulRight_apply, mul_comm]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "simp only [LinearMap.mulRight_apply, mul_comm]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "show mul_comm _ b = _"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "show Units.ext _ _ = _"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "rw [\u2190 mul_one b, LinearMap.mulRight_apply, one_mul]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "rw [\u2190 IsScalarTower.assoc, LinearMap.mulRight_apply]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "apply smul_comm"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "show IsScalarTower R A A := { carrier := smul_assoc a b }"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "simp [\u2190 mul_assoc]"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "show mul_comm b a = _"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "show RingHom.id _ _ = _"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "show MulOpposite.op _ b = _"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "suffices : Function.update a b 0 = 0"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "show MulAction.mulRight R a b = b * a"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "suffices : (LinearMap.mulRight R a b).LinearMap.compRight a = b * a"}, {"state": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\na b : A\n\u22a2 \u2191(mulRight R a) b = b * a", "positive": "simp [LinearMap.mulRight]", "negative": "simp [mul_comm b a]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction' n with n ih"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction' n with n hn"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction' n with n ihn"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction' n with n _"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, pow_succ]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, MonoidHom.map_pow]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction' n with n n_ih"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, pow_succ, MonoidHom.map_mul]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, pow_succ', MonoidHom.iterate_map_mul]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction' n with n IH"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, pow_succ, MonoidHom.iterate_map_mul]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, MonoidHom.iterate_map_one]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, MonoidHom.iterate_map_pow]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, MonoidHom.iterate_map_mul]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, Monoid.End.monoidHom_iterate]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, pow_succ, \u2190 MonoidHom.iterate_map_mul]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction' n with d hd"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction' n with n n"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction' n with n"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, pow_succ, -MonoidHom.iterate_map_mul]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, MonoidHom.iterate_map_zero]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, pow_succ', -MonoidHom.iterate_map_mul]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, MonoidHom.iterate_map_one, MonoidHom.iterate_map_one]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction' n with _ n_ih"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, MonoidHom.iterate_map_one, id]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, pow_succ, \u2190 MonoidHom.map_mul]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [pow_succ, MonoidHom.map_mul, *]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, pow_succ', \u2190 MonoidHom.iterate_map_mul]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "cases' n with n"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, MonoidHom.iterate_map_one, pow_succ]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction' n using Nat.strong_induction_on with n ih"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, pow_succ, map_mul]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction' n with n ih <;> simp [*]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, MonoidHom.iterate]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, MonoidHom.map_mul]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "cases n"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, pow_succ, mul_iterate]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, MonoidHom.map_pow, MonoidHom.iterate_map_one]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, pow_succ', mul_iterate]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, MonoidHom.iterate_map_one, MonoidHom.iterate_id]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, one_pow]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, pow_succ', Function.iterate_map_mul]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, pow_succ, MonoidHom.map_mul, MonoidHom.iterate_map_one]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul, MonoidHom.iterate_map_mul]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, hom_pow]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [pow_succ, MonoidHom.iterate_map_mul, *]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, pow_succ, MonoidHom.map_mul, MonoidHom.iterate_map_mul]"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "cases' n with n n"}, {"state": "M\u271d : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf : Monoid.End M\nn : \u2115\n\u22a2 \u2191(f ^ n) = (\u2191f)^[n]", "positive": "induction n <;> simp [*, pow_succ', MonoidHom.map_mul]", "negative": "induction n <;> simp [*, MonoidHom.iterate_map_one, Function.iterate_id]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact cofinite_basis_Ioi.comap_comap _"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact Filter.comap_mono Filter.cofinite_le_cofinite"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "rw [Filter.comap_cofinite]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "rw [\u2190 Filter.tendsto_iff_comap]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact Filter.comap_mono le_rfl"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact Filter.comap_mono le_top"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "refine' comap_le_iff_le_cofinite.mpr fun s hs => _"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact Filter.comap_mono (Filter.cofinite_mem_cofinite _)"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "rw [\u2190 Filter.comap_cofinite]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "rw [Filter.comap_le_iff_le_cofinite]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "refine' Filter.comap_mono fun s hs => _"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact cofinite_basis_Ioi.comap_cofinite"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "refine' cofinite_le_cofinite.trans _"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "refine' (Filter.comap_mono Filter.cofinite_le_cofinite).2 fun s hs => _"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact (Filter.hasBasis_cofinite _).Filter.HasBasis.le_basis_iff Filter.hasBasis_cofinite"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact Filter.comap_mono (by simp)"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact cofinite_basis.comap _"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact comap_id.comap_le"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact Filter.comap_cofinite_le"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact cofinite_basis_Ioi.comap_comap f"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact Filter.comap_mono h"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact cofinite_basis.comap_comap _"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact cofinite_basis.comap_cofinite_le_cofinite"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "rw [Filter.comap_cofinite, Filter.comap_iInf]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact comap_cofinite.ge"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact cofinite_basis.comap_cofinite"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact Filter.comap_le_cofinite_of_mem"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact cofinite_basis.comap_le_cofinite_iff"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact (Filter.hasBasis_cofinite _).Filter.HasBasis.le_basis_iff Filter.cofinite_basis_sets"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact cofinite_basis.comap_le_cofinite"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "rw [(cofinite.basis_sets.comap _).Filter.HasBasis.le_basis_iff Filter.hasBasis_cofinite]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact cofinite_basis.le_basis_iff Filter.cofinite_basis"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact cofinite_basis.le_basis_iff _"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "refine' comap_le_cofinite.trans _"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "refine' cofinite_basis.ge_iff.2 fun U hU => _"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "refine' (comap_nonempty_iff.mpr Filter.cofinite_neBot).2 fun s hs => _"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact Filter.comap_cofinite_le_cofinite"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "rw [\u2190 Filter.principal_univ]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact cofinite_basis.comap_le_cofinite_iff.2 inferInstance"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact Filter.comap_mono Filter.cofinite_mem_cofinite"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact comap_is_cofinite.ge"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "refine' comap_le_iff_le_cofinite.mpr fun U hU => _"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact Filter.comap_mono fun s => Filter.monotone_cofinite"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact Filter.comap_mono (Filter.cofinite_mem_cofinite_subset _)"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact cofinite_basis_cofinite.comap_le"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact cofinite_basis.comap_cofinite_le _"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "refine' (Filter.comap_mono Filter.cofinite_le_cofinite).2 fun t ht => _"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "rw [(Filter.hasBasis_cofinite _).Filter.HasBasis.le_basis_iff Filter.hasBasis_cofinite]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact (Filter.basis_sets _).Filter.HasBasis.le_basis_iff Filter.cofinite_basis_cofinite"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact (Filter.basis_sets _).Filter.HasBasis.le_basis_iff Filter.cofinite_basis_sets"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact Filter.comap_cofinite_le_cofinite _"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact Filter.comap_mono subset_cofinite"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact (cofinite_basis.comap _).Filter.HasBasis.le_basis_iff Filter.cofinite_basis"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "rw [Filter.comap_le_iff_le_cofinite, Filter.comap_cofinite]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact Filter.comap_mono fun s => Filter.mem_cofinite_self"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "refine' comap_le_iff_le_comap.mpr fun s hs => _"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact Filter.comap_mono (Filter.cofinite_mem_cofinite_sets _)"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact cofinite_basis.comap_le_cofinite_cofinite"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact (Filter.basis_cofinite _).Filter.HasBasis.le_basis_iff Filter.cofinite_basis_sets"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact Filter.comap_mono (Filter.cofinite_le_cofinite _)"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact cofinite_basis_cofinite.comap_le_cofinite"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact (Filter.hasBasis_cofinite _).Filter.HasBasis.le_basis_iff (cofinite_basis_Ioi.comap _)"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap f cofinite \u2264 cofinite", "positive": "intro s hs", "negative": "exact Filter.comap_le_cofinite_of_cofinite_subset f"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "simp only [Filter.mem_comap]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.mem_comap_of_mem hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "contrapose! hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "simp only [Filter.mem_comap, Filter.mem_cofinite]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "rw [Filter.mem_comap]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "rcases Filter.mem_cofinite.1 hs with \u27e8t, ht, hts\u27e9"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "rw [Filter.mem_cofinite] at hs \u22a2"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.mem_comap_sets hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "rcases Filter.mem_cofinite.1 hs with \u27e8t, ht, st\u27e9"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.mem_comap_of_mem f hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "contrapose hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.mem_comap.2 \u27e8s, hs, Filter.mem_cofinite.2 hs\u27e9"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "simp only [Filter.mem_cofinite, Filter.mem_comap]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "rw [Filter.mem_cofinite]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.comap_mem_cofinite hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "simp only [Filter.mem_comap, Filter.mem_preimage]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.mem_comap_self hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "simp only [Filter.mem_comap']"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "rw [Filter.mem_cofinite, Filter.mem_comap]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "rcases Filter.mem_cofinite.1 hs with \u27e8t, ht, hs\u27e9"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.comap_mem_cofinite_subset hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.mem_comap_self _ hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.mem_comap_sets _ hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.comap_mem_cofinite_subset _ hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.preimage_mem_cofinite hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "simp only [Filter.mem_comap, Filter.mem_cofinite] at hs \u22a2"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "rw [Filter.mem_comap']"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "simp only [Filter.mem_comap', Filter.mem_cofinite]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "simp_rw [Filter.mem_comap]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "simp only [Filter.mem_comap, exists_prop]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.comap_mem_cofinite_of_mem hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.mem_comap.2 \u27e8_, hs, Filter.mem_cofinite.2 hs\u27e9"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.mem_comap_self s hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "simp only [Filter.mem_comap, Filter.mem_principal]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "rcases Filter.mem_cofinite.1 hs with \u27e8t, ht, -\u27e9"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.subset_comap.2 \u27e8s, hs, Filter.mem_cofinite.2 hs\u27e9"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.mem_comap.2 \u27e8s, hs, rfl\u27e9"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.mem_comap_self _ _ hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.preimage_mem_comap hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.comap_mem_cofinite_sets hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "simp only [Filter.mem_comap, Filter.mem_cofinite] at *"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.mem_comap.2 \u27e8s, hs, by simpa\u27e9"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.mem_comap.2 \u27e8s, hs, Filter.preimage_mem_cofinite hs\u27e9"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.comap_mem_cofinite _ hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "simp only [Filter.mem_comap] at hs \u22a2"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.mem_comap_of_mem _ hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.mem_comap.2 \u27e8s\u1d9c, hs, Filter.mem_cofinite.2 hs\u27e9"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.mem_comap'.2 \u27e8s, hs, Filter.mem_cofinite.2 hs\u27e9"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "simp only [Filter.mem_comap', Filter.mem_preimage]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.mem_comap.2 \u27e8s, hs, by simpa using hs\u27e9"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "rcases Filter.mem_cofinite.1 hs with \u27e8s, hsf, hfs\u27e9"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.Finite.mem_comap_of_mem hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "simp only [Filter.mem_comap] at *"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.mem_comap'' hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.comap_mem_cofinite_subset f hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "simpa only [Filter.mem_comap, Filter.mem_cofinite] using hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.subset_comap.2 \u27e8_, hs, Filter.mem_cofinite.2 hs\u27e9"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "exact Filter.subset_comap.2 hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 s \u2208 comap f cofinite", "positive": "simp only [Filter.mem_comap'']", "negative": "simp only [Filter.mem_comap, Set.Finite.mem_cofinite]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "rw [Filter.mem_cofinite, Filter.mem_cofinite] at hs \u22a2"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "rwa [Filter.mem_cofinite, Filter.mem_cofinite] at hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "cases hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "cases nonempty_fintype s"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "cases' Filter.mem_cofinite.1 hs with t ht"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "rw [Filter.mem_cofinite, Filter.mem_comap''] at hs \u22a2"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "rwa [Filter.mem_cofinite, \u2190 Filter.mem_comap''] at hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "cases' hs with t ht"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "rw [Filter.mem_cofinite, \u2190 Filter.mem_comap''] at hs \u22a2"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "cases isEmpty_or_nonempty \u03b1"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "rwa [Filter.mem_cofinite] at hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "revert hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "rw [Filter.mem_cofinite, Filter.mem_comap] at hs \u22a2"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "intro t ht"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "rwa [Filter.mem_cofinite, \u2190 Filter.mem_comap'']"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "rwa [Filter.mem_cofinite, \u2190 Filter.mem_cofinite] at hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "contrapose! hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "induction' hs with s hs IH"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "cases' Filter.mem_cofinite.1 hs with b hb"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "simpa [Filter.mem_cofinite] using hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "rwa [Filter.mem_cofinite, Filter.mem_comap''] at hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "induction' hs with s hs ih"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "induction hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "rw [Filter.mem_cofinite, \u2190 Filter.mem_comap] at hs \u22a2"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "rw [Filter.mem_cofinite, \u2190 Filter.mem_cofinite] at hs \u22a2"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "induction hs generalizing s"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "cases Filter.mem_cofinite.1 hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "rwa [Filter.mem_cofinite, \u2190 Filter.mem_comap]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "rw [Filter.mem_cofinite, Set.kernImage] at hs \u22a2"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "rw [Filter.mem_cofinite, Filter.mem_comap''] at hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "rw [\u2190 Filter.mem_comap''] at hs \u22a2"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "induction' hs with t ht"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "rwa [Filter.mem_cofinite, \u2190 Filter.mem_comap] at hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "rwa [Filter.mem_cofinite, \u2190 Filter.mem_cofinite]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "rw [\u2190 Filter.mem_cofinite] at hs \u22a2"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "cases' hs with hsf"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "induction' hs with s hs ihs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "cases' hs with hsf hss"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "rwa [Filter.mem_cofinite, Filter.mem_cofinite]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "simpa using hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "induction' hs with t ht IH"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "simp only [Set.mem_cofinite, Filter.mem_cofinite] at hs \u22a2"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "cases' Filter.mem_cofinite.1 hs with U hU"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "rw [Filter.mem_cofinite, Filter.mem_kernImage] at hs \u22a2"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "cases subsingleton_or_nontrivial \u03b1"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "rcases Filter.mem_cofinite.1 hs with \u27e8t, ht, hts\u27e9"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "rw [\u2190 Filter.mem_comap'']"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "induction' hs with s hs ih generalizing s"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "rwa [\u2190 Filter.mem_comap'']"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "cases' Filter.mem_cofinite.1 hs with y hy"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "cases' Filter.mem_cofinite.1 hs with g hg"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "rw [Filter.mem_cofinite, Filter.mem_cofinite'] at hs \u22a2"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "cases' Filter.mem_cofinite.1 hs with hsf hss"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s \u2208 cofinite\n\u22a2 kernImage f s \u2208 cofinite", "positive": "rw [Filter.mem_cofinite] at hs \u22a2", "negative": "rwa [Filter.mem_cofinite, Filter.mem_cofinite] at hs \u22a2"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "cases hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rwa [Set.kernImage_eq_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Set.kernImage_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Set.compl_eq_univ_diff]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Set.kernImage_eq_image]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Filter.kernImage_eq_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rwa [Set.kernImage_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Filter.kernImage_eq_iInf]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "cases hs.nonempty_fintype"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [compl_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Set.kernImage_eq_compl, compl_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Set.kernImage_eq_kernImage]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rwa [Set.compl_eq_univ_diff]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "induction hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Filter.kernImage_eq]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Set.kernImage_eq_compl_image]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Set.kernImage_eq_compl_inter]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Set.kernImage_eq_image, compl_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "cases' hs with h h"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Set.kernImage_eq_compl_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Set.kernImage_eq_preimage]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Set.kernImage_eq_biInter]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rwa [Set.kernImage_eq_compl, compl_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "simp only [Set.kernImage_eq_compl, compl_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "classical rw [Set.kernImage_eq_compl] exact hs.compl_mem_cofinite"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Filter.kernImage_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Set.kernImage_eq_image_preimage]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "cases nonempty_fintype \u03b1"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Set.kernImage_eq_preimage_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Set.kernImage_eq_left]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [\u2190 Set.preimage_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "cases' hs with hs hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Set.compl_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Filter.compl_surjective]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "classical rw [Set.kernImage_eq_compl] exact Set.Finite.compl hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [\u2190 Set.preimage_kernImage_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "classical rw [Set.kernImage_eq_compl] exact hs.compl"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Set.kernImage_eq_image_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Set.compl_eq_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "cases nonempty_fintype s"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Set.quotient_compl_self]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Set.kernImage_eq_kernImage_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Filter.kernImage_eq_cofinite]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Set.kernImage_eq]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [s\u1d9c.Set.compl_eq_univ_diff]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "cases hs.nonempty_toFinset"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Set.preimage_kernImage_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "cases s"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Set.finite_compl_iff]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [\u2190 Set.biUnion_of_singleton s]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [s.finite_compl_iff]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Set.kernImage_eq_set]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Filter.kernImage_eq_preimage_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rwa [Set.compl_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Set.kernImage_eq_compl_nonempty]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "cases' hs with hf hf"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [\u2190 Filter.mem_cofinite] at hs \u22a2"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Filter.finite_iff_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "simp [Set.kernImage_eq_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Set.kernImage_eq_image_subset]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (kernImage f s)\u1d9c", "positive": "rw [Set.kernImage_eq_compl]", "negative": "rw [Set.kernImage_eq_set_preimage_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "rw [compl_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa using hs.compl_mem_cofinite"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simp [compl_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "exact (hs.image f).Set.Finite.compl_mem_cofinite"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa only [compl_compl] using hs.compl_mem_cofinite"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "exact hs.compl_mem_cofinite"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "exact (hs.image _).Set.Finite.compl_mem_cofinite"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa using hs.union (by simp)"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "rwa [compl_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa using hs.union hs.compl_mem_cofinite"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa using hs.union (by simpa)"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa using (hs.image f).Set.Finite.compl_mem_cofinite"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa only [compl_compl] using (hs.image f).Set.Finite.compl_mem_cofinite"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa [compl_compl] using hs.compl_mem_cofinite"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "exact hs.finite_compl"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa using hs.subset"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "rw [Set.compl_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simp [Set.compl_image]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simp [Set.finite_compl hs]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simp [Set.finite_compl_iff, compl_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simp [Set.finite_compl_iff]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "exact (hs.image f).Set.Finite.finite_compl"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa only [compl_compl] using hs.compl"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "exact (hs.image _).Set.Finite.finite_compl"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simp"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa [Set.compl_image] using hs.compl_mem_cofinite"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simp [compl_inj_iff]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "rw [\u2190 Set.kernImage_eq_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa [Set.finite_compl_iff] using hs.compl_mem_cofinite"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simp [Set.finite_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "exact hs.compl_finite_image _"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simp only [compl_compl, Set.finite_compl_iff]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa [compl_compl] using hs.compl"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "rw [Set.finite_compl_iff]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa using hs.union (by simp [Set.finite_compl_iff])"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa using hs.union (Set.finite_compl_image _ _)"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simp only [compl_compl, Set.finite_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa using (hs.image f).Set.Finite.finite_compl"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa only [compl_compl] using (hs.image f).Set.Finite.finite_compl"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa using hs.finite_compl"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa using Set.Finite.compl_mem_cofinite hs"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa using hs.union (by simpa using hs.compl)"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simp [Set.finite_compl_iff.1 hs]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa using hs.union (hs.image f).Set.Finite.compl_mem_cofinite"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "exact (hs.image f).Set.Finite.compl"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "exact hs.image _"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa [compl_compl] using (hs.image f).Set.Finite.compl_mem_cofinite"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "rw [Set.compl_image_compl]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa using hs.union (Set.finite_compl_image f s\u1d9c)"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa using hs.compl"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "exact hs.subset"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simp [Filter.finite_compl hs]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "rw [\u2190 Filter.mem_cofinite]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa using hs.union (by simp [compl_compl])"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa only [compl_compl] using hs.compl_finite_image f"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simp [compl_injective]"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa using hs.union (by simpa using hs)"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa only [compl_compl] using hs.subset"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "exact hs.compl_finite_image f"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa using hs.union (Set.finite_compl hs.compl)"}, {"state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Finite s\u1d9c\n\u22a2 Set.Finite (f '' s\u1d9c)\u1d9c\u1d9c", "positive": "simpa using hs.image f", "negative": "simpa [Set.compl_image] using hs.compl"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "constructor <;> intro h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "rw [eq_comm, NonemptyInterval.ext_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "constructor"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "rw [eq_comm]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "constructor <;> intro h <;> rw [h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "rw [\u2190 NonemptyInterval.ext_iff, NonemptyInterval.ext_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "rw [\u2190 NonemptyInterval.ext_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "constructor <;> intro h <;> rfl"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "constructor <;> intros <;> rfl"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "constructor <;> intro h <;> exact h.symm"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "constructor <;> intro h <;> conv_rhs => rw [h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "cases' s with a t"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "cases s <;> simp"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "rw [SetLike.ext'_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "cases s <;> rfl"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "cases' s with f al"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "convert NonemptyInterval.ext_iff s t.toProd"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "conv_rhs => rw [\u2190 NonemptyInterval.ext_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "constructor <;> intro H"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "cases s <;> cases t"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "constructor <;> rintro rfl"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "cases s <;> simp [SetLike.ext'_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "rw [eq_comm, NonemptyInterval.ext_iff, NonemptyInterval.ext_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "constructor <;> intro h <;> constructor <;> assumption"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "rw [SetLike.ext'_iff, NonemptyInterval.ext_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "convert Iff.rfl"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "constructor <;> intro h <;> contradiction"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "conv_rhs => rw [\u2190 NonemptyInterval.ext_iff s t]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "cases, s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "constructor <;> intro h <;> rw [h] <;> exact h.symm"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "cases' s with a s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "casess s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "rw [@eq_comm _ s, NonemptyInterval.ext_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "cases s <;> simp [SetLike.ext_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "cases' s with a <;> cases t"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "constructor <;> intros"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "constructor <;> intro h <;> tauto"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "cases s <;> simp_all"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "constructor <;> intros <;> simp_all"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "cases s <;> simp [Function.funext_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "constructor <;> intro h <;> congr"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "rw [SetLike.ext_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "constructor <;> intro h <;> constructor <;> rfl"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "rw [\u2190 NonemptyInterval.ext_iff, \u2190 NonemptyInterval.ext_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "cases' s with a b"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "conv_rhs => rw [\u2190 NonemptyInterval.subtype_ext_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "constructor <;> intro h <;> rw [h] <;> exact h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "constructor <;> intro h <;> constructor <;> apply h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "rw [\u2190NonemptyInterval.ext_iff, NonemptyInterval.ext_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "rw [\u2190 NonemptyInterval.subtype_ext_iff, NonemptyInterval.subtype_ext_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "constructor <;> intros <;> exact h.symm"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "rw [\u2190NonemptyInterval.ext_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "constructor <;> exact NonemptyInterval.ext_iff"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "rw [\u2190 NonemptyInterval.subset_zero_iff, NonemptyInterval.subset_zero_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "casest s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "constructor <;> intro h <;> constructor <;> aesop"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "conv_lhs => rw [\u2190 NonemptyInterval.ext_iff s t]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "rw [eq_comm, NonemptyInterval.ext_iff, eq_comm]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "rw [SetLike.ext_iff, NonemptyInterval.ext_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "conv_rhs => rw [\u2190 t.toProd_injective.eq_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "constructor <;> intro h <;> simp_all"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "constructor <;> intro"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns\u271d t\u271d s t : NonemptyInterval \u03b1\n\u22a2 s = t \u2194 s.toProd = t.toProd", "positive": "cases s", "negative": "constructor <;> intro h <;> constructor <;> intro h"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "cases t"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "congr"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> exact Prod.ext_iff"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> assumption"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "exact Prod.ext_iff"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> rfl"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> exact NonemptyInterval.ext_iff _ _"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "exact Prod.mk.inj_iff"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "exact NonemptyInterval.ext_iff _ _"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> exact NonemptyInterval.ext_iff"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "exact NonemptyInterval.mk_eq_iff"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "exact NonemptyInterval.mk_eq_mk_iff"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> exact NonemptyInterval.mk_eq_iff"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> intro h"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> exact NonemptyInterval.mk_eq_mk_iff"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "case mk => exact Prod.ext_iff"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "exact NonemptyInterval.mk_iff_eq"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> exact Prod.mk.inj_iff"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> exact Iff.rfl"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> exact Sym2.eq_iff"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> intros <;> assumption"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "exact NonemptyInterval.mk_iff"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "exact NonemptyInterval.mk_eq_iff _ _"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "casest t"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> exact Sigma.eq"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> exact NonemptyInterval.mk_eq_iff _ _"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> exact Prod.ext_iff \u2039_\u203a"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> exact NonemptyInterval.ext _ _"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "case mk => exact NonemptyInterval.ext_iff _ _"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> exact NonemptyInterval.mk_iff_eq"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "exact NonemptyInterval.ext_iff"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "case mk => assumption"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "convert Prod.ext_iff"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> exact NonemptyInterval.ext_iff _ _ _"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> exact Prod.ext_iff.2 \u2039_\u203a"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> exact Prod.ext \u2039_\u203a \u2039_\u203a"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "cases_t"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "contrapose!"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> exact Prod.ext \u2039_\u203a <;> assumption"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "exact Prod.mk_eq_mk"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "exact NonemptyInterval.mk_eq_mk"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "contradiction"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> intro h <;> assumption"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> exact NonemptyInterval.mk_iff_eq_toProd"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "exact Prod.mk.inj_iff \u2039_\u203a"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "case mk => exact Prod.ext_iff.2 \u2039_\u203a"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> intros <;> exact h.symm"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "cases[t"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> exact Prod.ext \u2039_\u203a <;> exact \u2039_\u203a"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "exact NonemptyInterval.mk_iff_eq_toProd"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> exact Sigma.mk.inj_iff"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "case mk => exact Prod.ext_iff.2 <| NonemptyInterval.ext_iff.1 h.symm"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "exact NonemptyInterval.ext_iff _ _ _"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "obtain \u27e8_, _\u27e9 := t"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "case mk => exact Prod.mk.inj_iff"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> exact Subtype.ext_iff"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> intro h <;> exact h.symm"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> exact Subsingleton.elim _ _"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> ext i"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "case mk => exact NonemptyInterval.mk_eq_mk_iff"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "case mk => exact NonemptyInterval.mk_iff_eq"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_6\ninst\u271d : LE \u03b1\ns t\u271d t : NonemptyInterval \u03b1\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\n\u22a2 { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d } = t \u2194\n    { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd = t.toProd", "positive": "constructor <;> aesop", "negative": "constructor <;> exact FunLike.ext_iff"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "lift f to \u03b1 \u2192 \u211d\u22650 using hf"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 NNReal.summable_coe]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [Summable, Pi.zero_apply]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [Subtype.forall', Subtype.coe_mk]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [Subtype.coe_mk]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_summable]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [Summable]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 summable_const_iff]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simpa only [\u2190 NNReal.summable_coe] using NNReal.summable_coe"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [Subtype.forall, Subtype.coe_mk]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 NNReal.summable_coe, Subtype.coe_mk]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 summable_congr hf, Subtype.coe_mk]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [Subtype.forall', Pi.zero_apply]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [Summable, Subtype.coe_mk]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [Subtype.coe_mk, Subtype.coe_mk]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 Subtype.coe_mk]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [Summable, NNReal.coe_mk]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [Subtype.coe_mk, Pi.zero_apply]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_summable, Subtype.coe_mk]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 Subtype.range_coe_summable]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [Summable, Pi.mul_apply]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [Summable, NNReal.summable_coe]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 summable_const_iff, hf, Subtype.coe_mk]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_eq]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [Subtype.forall'] at hf"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 summable_congr hf]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [Subtype.summable_coe_fn]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [Subtype.summable_coe]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simpa only [\u2190 NNReal.summable_coe] using NNReal.summable_sum hf"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 Subtype.range_coe] at hf"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [Subtype.forall, Pi.zero_apply]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 NNReal.summable_coe, NNReal.summable_coe]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 summable_const_iff, hf]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 summable_const_iff_of_nonneg hf]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 FunLike.coe_fn_eq]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [Subtype.forall', Pi.zero_apply, Subtype.coe_mk]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [Summable, Subtype.forall]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 Real.summable_coe]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [Summable, ENNReal.toReal_eq_zero_iff]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 summable_const]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simpa only [\u2190 NNReal.summable_coe] using NNReal.summable_summable_iff hf"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [Summable, \u2190 NNReal.summable_coe]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 Subtype.coe_mk, Subtype.coe_mk]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 summable_const_iff_of_nonneg hf, Subtype.coe_mk]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 Function.mk_eq_mk _ hf]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 summable_const_mul_iff hf, Subtype.coe_mk]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [Summable, ENNReal.toReal_nonneg]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simpa only [\u2190 NNReal.summable_coe] using summable_const"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 summable_const_iff hf, Subtype.coe_mk]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 Function.comp_apply, Summable]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [Summable, Function.Embedding.coeFn_mk]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 Subtype.coe_mk _ hf, Subtype.coe_mk]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 summable_const_iff, Subtype.coe_mk]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 Function.comp.left_id f, Subtype.coe_mk]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "rw [\u2190 summable_congr hf]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [Subtype.summable_coe_subtype]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [Subtype.summable_coe_fn_mk hf]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 summable_const_iff, hf, forall_const]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 Function.comp_apply (f := \u211d)]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [Function.Embedding.coeFn_mk]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 Function.comp_apply (f := \u211d) \u211d]"}, {"state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 (n : \u03b1), 0 \u2264 f n\n\u22a2 (Summable fun n => { val := f n, property := (_ : 0 \u2264 f n) }) \u2194 Summable f", "positive": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_mk]", "negative": "simp only [\u2190 Function.comp_apply, Subtype.coe_mk]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup_subtype]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup_subtype']"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup_subtype, iSup_subtype]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm (iSup_le fun i => _)"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup_subtype'']"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> refine' iSup_le fun i => _"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup_subtype', iSup_subtype']"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup_subtype, AddSubmonoid.iSup_eq_closure]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rintro x \u27e8f, rfl\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "rw [iSup, AddSubmonoid.iSup_eq_closure]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [\u2190 iSup_subtype'']"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup, AddSubmonoid.iSup_eq_closure]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm (iSup_le _)"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "change iSup S = _"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [\u2190 iSup_subtype]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "convert iSup_unique S"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup_subtype', AddSubmonoid.iSup_eq_closure]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup_subtype, DFinsupp.mrange_sumAddHom]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup_subtype, iSup_unique]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rintro x \u27e8v, rfl\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "rw [iSup, AddMonoidHom.mrange_coe]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "rw [AddSubmonoid.iSup_eq_closure]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup_addSubmonoid]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [\u2190 iSup_subtype'', iSup_subtype'']"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> refine' iSup_le _"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup, DFinsupp.mrange_sumAddHom]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "rw [iSup]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup_subtype'', iSup_subtype'']"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> intro i hi"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup_subtype, iSup_addSubmonoid]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup_subtype', DFinsupp.mrange_sumAddHom]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup_subtype', iSup_addSubmonoid]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup_subtype, \u2190 AddSubmonoid.iSup_eq_closure]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [\u2190 iSup_subtype']"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [\u2190 DFinsupp.range_subtype]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "rw [\u2190 iSup_subtype]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "rw [iSup, AddSubmonoid.iSup_eq_closure, AddMonoidHom.mrange_coe]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "rw [iSup, dif_pos]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup_subtype', iSup_subtype'']"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup_subtype', iSup_unique]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup_subtype, iSup_const]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "rw [iSup, MonoidHom.mrange_coe]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm (iSup_le fun i => AddSubmonoid.subtype_le (S i))"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [AddSubmonoid.iSup_eq_closure]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "rw [iSup, AddSubmonoid.iSup_eq_closure, iSup_range]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup_subtype, iSup_subtype']"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup, AddSubmonoid.iSup_subtype]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup_subtype', iSup_subtype]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [DFinsupp.mrange_sumAddHom]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "rw [\u2190 iSup_subtype'']"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "rw [iSup, AddSubmonoid.range_subtype]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm (iSup_le fun i => AddSubmonoid.le_sumAddHom _ _)"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm (iSup_le fun i => iSup_le fun h => _)"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm (iSup_le fun i => AddSubmonoid.iSup_subtype_eq (S i))"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "convert iSup_univ S"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup_subtype, iSup_subtype, AddSubmonoid.iSup_eq_closure]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup_subtype', \u2190 AddSubmonoid.iSup_eq_closure]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup_subtype, AddSubmonoid.sumAddHom_apply]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup_subtype, \u2190 AddSubmonoid.iSup_subtype]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup_addSubmonoid, iSup_subtype]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup, AddSubmonoid.sumAddHom_apply]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S = AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))", "positive": "apply le_antisymm", "negative": "apply le_antisymm <;> rw [iSup_subtype, AddSubmonoid.iSup_eq]"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "apply AddSubmonoid.iSup_le _"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "apply iSup_mono"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "apply AddSubmonoid.iSup_le_of_le"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "apply iSup_le"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "rw [iSup_le_iff]"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _ rintro x \u27e8v, rfl\u27e9 apply AddSubmonoid.subset_span"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "apply iSup_mono'"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _; simp"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "refine' iSup_le _"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "apply AddSubmonoid.iSup_le_iSup"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "refine' iSup_le fun i => _"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "apply sSup_le _"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _; convert iSup_le _"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _ rintro x \u27e8v, rfl\u27e9 apply AddSubmonoid.le_sumAddHom rfl"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "apply iSup_le_iSup"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "apply AddSubmonoid.iSup_le_sum"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "apply AddSubmonoid.iSup_mono"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _ rintro x \u27e8v, rfl\u27e9 apply AddSubmonoid.le_sumAddHom"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "apply iSup\u2082_le _"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _ rintro x \u27e8v, rfl\u27e9 exact \u27e8v, fun i => \u27e8\u27e8i, hi\u27e9, rfl\u27e9\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "apply single"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _ rintro x \u27e8v, rfl\u27e9; exact AddSubmonoid.subtype_le _"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _; intros; simp"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "apply AddSubmonoid.iSup_le_sumAddHom"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "apply AddSubmonoid.iSup_le_of_subset"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _ rintro x \u27e8v, rfl\u27e9 apply AddSubmonoid.subtype_le"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "apply single_le_iSup"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _; apply AddSubmonoid.le_sumAddHom"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _ rintro x \u27e8v, rfl\u27e9; exact \u27e8v, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "refine iSup_le fun i =>?_"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _ rintro x \u27e8v, rfl\u27e9 apply AddSubmonoid.mem_subtype_self"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "apply sigma_iSup_le"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _ rintro x \u27e8v, rfl\u27e9 apply AddSubmonoid.monotone_subtype"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "simp only [iSup_le_iff, DFinsupp.mrange_sumAddHom]"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _ rintro x \u27e8v, rfl\u27e9 simp"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _ rintro x \u27e8v, rfl\u27e9 exact \u27e8v, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _ rintro x \u27e8v, rfl\u27e9 apply AddSubmonoid.multiplicative_sumAddHom_le"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _; convert iSup_le _; rfl"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _; rintro x \u27e8v, rfl\u27e9; exact AddSubmonoid.subtype_le _"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _ rintro x \u27e8v, rfl\u27e9; exact \u27e8v, fun i => \u27e8\u27e8i, hi\u27e9, rfl\u27e9\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _ rintro x \u27e8v, rfl\u27e9 apply SetLike.coe_mem"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "apply iSup_le_of_le"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "rw [\u2190 iSup_subtype'']"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "apply AddSubmonoid.subset_span"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _ rintro x \u27e8v, rfl\u27e9 apply AddSubmonoid.mul_subtype_le"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _ rintro x \u27e8v, rfl\u27e9 apply Submonoid.mul_mem"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _ rintro i \u27e8v, rfl\u27e9 apply AddSubmonoid.subset_span"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "refine' iSup_le fun i => iSup_le fun i => _"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _; convert AddSubmonoid.subtype_le"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _ rintro x \u27e8v, rfl\u27e9 apply AddSubmonoid.mul_le"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _; convert AddSubmonoid.subtype_le S"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le_iSup"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _ rintro x \u27e8v, rfl\u27e9; exact AddSubmonoid.le_sumAddHom fun i => (S i).subtype.coe_prop"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _; rintro x \u27e8v, rfl\u27e9 apply AddSubmonoid.subset_span"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _ rintro x \u27e8v, rfl\u27e9 apply Submonoid.subset_span"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "apply AddSubmonoid.iSup_le"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le rintro x \u27e8v, rfl\u27e9 apply AddSubmonoid.subset_span"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _ rintro x \u27e8v, rfl\u27e9 apply AddSubmonoid.multiplicity_le_sumAddHom"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "rotate_left"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "all_goals apply iSup_le _"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "rw [AddSubmonoid.iSup_eq_closure]"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "apply sigma_mk_iSup_le"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 iSup S \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "apply iSup_le _", "negative": "apply AddSubmonoid.iSup_le_of_single"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "intro i"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "intro i x hx"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "apply iSup_le _"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "apply DFinsupp.le_sumAddHom"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "itro i y hy"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "exact fun i x hx => le_iSup _ _"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "apply iSup_le"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "apply @iSup_le _ _ _"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "exact fun i x hx => le_iSup S i \u27e8_, hx\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "swap"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "apply DFinsupp.induction"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "apply @iSup_le \u03b9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "exact fun i y hy => \u27e8DFinsupp.single i \u27e8y, hy\u27e9, rfl\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "exact fun i => le_iSup _ _"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "apply @iSup_le _ _"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "apply DFinsupp.induction S"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "apply @iSup_le \u03b9 _"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "apply DFinsupp.le_sSup"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "apply DFinsupp.le_mrange_sumAddHom"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "apply @iSup_le _ _ _ _"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "exact fun i x hx => \u27e8DFinsupp.single i x, DFinsupp.single_le_sum _ _ hx\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "apply @iSup_le _ _ S"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "apply @iSup_le"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "exact fun i => iSup_le fun i => le_iSup _ _"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "apply DFinsupp.mrange_sumAddHom_le"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "exact fun i y hy => le_iSup S i \u27e8_, hy\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "exact fun i y hy => le_iSup _ _"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "apply @iSup_le _ _ _ S"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "apply AddSubmonoid.le_sumAddHom"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "exact fun i y hy => \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le_sum _ _ hy\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "apply DFinsupp.le_mrange"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "exact fun i x hx => \u27e8\u27e8x, hx\u27e9, rfl\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "iterate i rintro i y \u27e8x, rfl\u27e9 exact le_iSup _ _"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "intros"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "exact fun i x hx => \u27e8_, rfl\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "exact fun i x hx \u21a6 le_iSup _ _"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "exact fun i => iSup_le fun i => le_iSup S i"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "exact fun i x hx => \u27e8DFinsupp.single i x, DFinsupp.single_le_iff.2 hx\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "apply AddSubmonoid.le_iSup_of_le"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "exact fun i x hx y hy => le_iSup S i \u27e8_, hx\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "exact fun i y hy => le_iSup S i \u27e8DFinsupp.single i \u27e8y, hy\u27e9, rfl\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "exact fun i => le_iSup S i"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "simp only [AddSubmonoid.sumAddHom_mrange, iSup_subtype']"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "apply @iSup_le \u03b9 _ _"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "apply DFinsupp.mrange_le_iSup"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "iterate i rintro i y \u27e8x, rfl\u27e9 j rfl"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "exact fun i x hx => le_iSup S i \u27e8x, hx\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "simp only [DFinsupp.mrange_sumAddHom, iSup_subtype']"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "exact fun i y hy => le_iSup S i \u27e8DFinsupp.single i \u27e8y, hy\u27e9\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "simp only [iSup_subtype']"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "iterate i rintro i y \u27e8x, rfl\u27e9 x hxy"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "apply DFinsupp.le_mrange_subtype"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "exact fun i x hx => le_iSup _ _ (hx i)"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "simp only [DFinsupp.mrange_sumAddHom]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "intros i"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "iterate i rintro i y \u27e8x, rfl\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "simp only [AddSubmonoid.sumAddHom_mrange]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "exact fun i x hx \u21a6 le_iSup S i \u27e8_, hx\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "exact fun i => \u27e8DFinsupp.single i \u27e8_, rfl\u27e9\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "simp only [AddSubmonoid.mrange_subtype]"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "apply DFinsupp.induction _ S"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 \u2200 (i : \u03b9), S i \u2264 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "intro i y hy", "negative": "apply @iSup_le _ \u03b9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le_iff.2 \u27e8i, hy\u27e9\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le_sum _ _ hy\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le_iff_mem.2 hy\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8\u27e8i, hy\u27e9, rfl\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le _ _\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_mem_subtype _ hy\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le_iff.2 hy\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, AddSubmonoid.subtype_mono _\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le_sum _ i hy\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le_iff_mem.2 \u27e8i, hy\u27e9\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le_sumAddHom _ _ _\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, AddSubmonoid.subtype_mem _\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le_sum _ _ i\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_mem_subtype.2 hy\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.mem_sumAddHom_single _ _ _\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8AddSubmonoid.subtype _, rfl\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le_iff.2 <| le_iSup _ _\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, rfl\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8AddSubmonoid.subtype _, le_iSup _ _\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le_iff.2 fun _ _ => AddSubmonoid.subtype_mem _\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le _ _ _\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, AddSubmonoid.subtype_le _\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_mono _ _ _\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le_iff.2 \u27e8i, rfl\u27e9\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le_sum _ _ _\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le_sum _ hy\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le_iff.2 fun _i => AddSubmonoid.subtype_mem _\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_mono _ hy\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8AddSubmonoid.subtype _, AddSubmonoid.subtype_mono _\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le_iSup _ _ hy\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8AddSubmonoid.subtype _, AddSubmonoid.mem_subtype_of_mem _ hy\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_mem_subtype _ _\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8AddSubmonoid.subtype _, le_sSup _ hy\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8\u27e8i, y\u27e9, rfl\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, le_sSup _ hy\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8iSup S i, AddSubmonoid.mem_subtype_of_mem _ hy\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8AddSubmonoid.subtype _, iSup_le fun i => AddSubmonoid.mem_subtype_of_mem _ hy\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le_iff.2 fun _ _ => AddSubmonoid.subtype_mono _\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le_iff.2 fun _i => AddSubmonoid.subtype_le _\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, AddSubmonoid.mem_subtype_of_mem _ hy\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le_iff.2 fun _ _ => AddSubmonoid.subtype_le _\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_mem_sumAddHom _ _ _\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le_iff_mem_support.2 hy\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le_sum _ _ i hy\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8AddSubmonoid.subtype (S i), rfl\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8AddSubmonoid.subtype _, le_iSup _ hy\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.mem_support_iff.2 hy\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8\u27e8i, S i\u27e9, rfl\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8iSup S i, iSup_le fun i => AddSubmonoid.mem_subtype_of_mem _ hy\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le_iff.2 \u27e8\u27e8i, hy\u27e9, rfl\u27e9\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le_iff.2 fun _ => AddSubmonoid.subtype_mem _\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8_, rfl\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8\u27e8i, hy\u27e9, le_sSup _ hy\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8AddSubmonoid.subtype (S i), AddSubmonoid.mem_subtype_of_mem _ hy\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le_iff.2 <| AddSubmonoid.subtype_le _\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le_iff.2 <| le_iSup S i\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le_iff.2 <| AddSubmonoid.subtype_mem _\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, dfinsupp_sumAddHom_single _ _ _\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le_iff.2 fun _ _ => AddSubmonoid.mem_subtype_of_mem _ hy\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le _ _ hy\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.single_le_iff_mem_iSup.2 \u27e8i, hy\u27e9\u27e9"}, {"state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\ni : \u03b9\ny : \u03b3\nhy : y \u2208 S i\n\u22a2 y \u2208 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i))\n\ncase a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, DFinsupp.sumAddHom_single _ _ _\u27e9", "negative": "exact \u27e8DFinsupp.single i \u27e8y, hy\u27e9, iSup_le_iSup _ _\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro _ \u27e8x, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro - \u27e8x, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro x \u27e8f, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro x \u27e8v, rfl : v = _, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro x \u27e8v, hv, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro v \u27e8v', rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro v \u27e8f, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro _ \u27e8i, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro a \u27e8x, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro x \u27e8v, rfl : v = S i, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "apply iSup_le _"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro \u27e8x, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro - \u27e8i, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro - \u27e8f, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "apply AddSubmonoid.mrange_sumAddHom_le"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "apply AddSubmonoid.range_sumAddHom_le"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro x \u27e8v, hv\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro x \u27e8v, rfl : v = _\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro v \u27e8i, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro _ \u27e8f, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro - \u27e8T, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro v \u27e8x, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro x \u27e8v, rfl, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro v \u27e8a, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro v \u27e8_, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "apply AddSubmonoid.sumAddHom_mono"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "apply AddSubmonoid.mrange_sum_le"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro x \u27e8v, rfl : v = iSup S, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro y \u27e8x, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro _ \u27e8a, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro x \u27e8v\u2081, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "apply AddSubmonoid.range_subtype_le"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro _ \u27e8v, rfl : v = _, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro \u27e8v, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "apply DFinsupp.mrange_sumAddHom_le"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro x\u2080"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "apply AddSubmonoid.sumAddHom_mrange_le"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro x \u27e8v, rfl, hx\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro x"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro x \u27e8v, -, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "apply Submonoid.map_iSup_le"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "apply Submonoid.range_sumAddHom_le"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro x \u27e8v, rfl : v = 1, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro x \u27e8v, rfl : v = iSup S\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro x \u27e8v, hp, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro / \u27e8x, rfl\u27e9"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "apply AddSubmonoid.mk_le_iSup_of_mem"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "apply Submonoid.sumAddHom_mono"}, {"state": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\n\u22a2 AddMonoidHom.mrange (sumAddHom fun i => AddSubmonoid.subtype (S i)) \u2264 iSup S", "positive": "rintro x \u27e8v, rfl\u27e9", "negative": "rintro - \u27e8s, rfl\u27e9"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).Subtype.prop"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ v fun i _ => (le_iSup S i : S i \u2264 _) (v i).2"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).Subtype.prop"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ v fun i _ => (le_iSup S i : S i \u2264 _) (v i).Subtype.prop"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.sumAddHom_mem _ v fun i _ => (le_iSup S i : S i \u2264 _) (v i).2"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).Subtype.prop"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.dfinsupp_sumAddHom_mem _ v _"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ _ v fun i _ => (le_iSup S i : S i \u2264 _) (v i).2"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ v _"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.sum_mem _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ _ v fun i _ => (le_iSup S i : S i \u2264 _) (v i).Subtype.prop"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.sumAddHom_mem _ v _"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.sumAddHom_mem _ _ v fun i _ => (le_iSup S i : S i \u2264 _) (v i).2"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.sumAddHom_mem _ v fun i _ => (le_iSup S i : S i \u2264 _) (v i).Subtype.prop"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.dfinsupp_sumAddHom_mem _ v fun i _ => (le_iSup S i : S i \u2264 _) (v i).2"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.mem_iSup_of_mem _ v.mem_range"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).Subtype.prop"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.dfinsupp_sumAddHom_mem _ v _ fun i _ => (v i).Subtype.prop"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).Subtype.prop"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ v _ fun i _ => (AddSubmonoid.subtype (S i)).2"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ v _ (le_iSup S v)"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) v i"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.sumAddHom_mem _ v _ (le_iSup _ _)"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.dfinsupp_sumAddHom_mem _ v fun i _ => (le_iSup S i : S i \u2264 _) (v i).Subtype.prop"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ v _ fun i _ => (v i).Subtype.prop"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.sumAddHom_mem _ v _ (le_iSup S v)"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ v fun i _ => (le_iSup S i : S i \u2264 _) v i"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact dfinsupp_sumAddHom_mem _ v _"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ v _ fun i _ => le_iSup S i p"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ v _ fun i _ => le_iSup S i"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.dfinsupp_sumAddHom_mem v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ v _ fun i _ => (AddSubmonoid.subtype (S i)).Subtype.prop"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.sum_mem _ v fun i _ => (le_iSup S i : S i \u2264 _) (v i).2"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ v fun i _ => (AddSubmonoid.subtype (S i)).2"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.sumAddHom_mem _ _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.sumAddHom_mem _ _ v fun i _ => (le_iSup S i : S i \u2264 _) (v i).Subtype.prop"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).Subtype.prop"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.dfinsupp_sumAddHom_mem v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).Subtype.prop"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ v _ fun i _ => (le_iSup S i).LE.le.trans (v i).Subtype.prop"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ v _ fun i _ => (le_iSup S i).LE.le.trans (le_iSup S i)"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.DFinsupp.sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.dfinsupp_sumAddHom_mem _ v _ fun i _ => (v i).2"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.dfinsupp_sumAddHom_mem _ v _ fun i _ => (AddSubmonoid.subtype (S i)).2"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).Subtype.prop"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ v fun i _ => (le_iSup S i).LE.le.trans (v i).Subtype.prop"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i).LE.le.trans (v i).Subtype.prop"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 iSup S) i"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ v _ (le_iSup _ _)"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact Submonoid.sum_mem _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ v fun i _ => (v i).Subtype.prop"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ v fun i _ => (le_iSup S i).LE.le.trans (le_iSup S i)"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.sum_mem _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).Subtype.prop"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) v i"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact DFinsupp.sumAddHom_mem _ _ _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.mem_iSup_of_mem S v.mem_range"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.mem_iSup_of_mem _ (v i).2"}, {"state": "case a.intro\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : AddCommMonoid \u03b3\nS : \u03b9 \u2192 AddSubmonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), { x // x \u2208 S i }\n\u22a2 \u2191(sumAddHom fun i => AddSubmonoid.subtype (S i)) v \u2208 iSup S", "positive": "exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i \u2264 _) (v i).2", "negative": "exact AddSubmonoid.dfinsupp_sumAddHom_mem _ v _ fun i _ => (AddSubmonoid.subtype (S i)).Subtype.prop"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "convert Part.get_mem o"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "convert Part.get_mem o h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "exact Part.get_mem _"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "convert Part.get_mem h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "have := Part.get_mem o h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "have h := Part.get_mem h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rw [h.get]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "convert Part.get_mem _"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "have h := Part.get_mem o h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "exact Part.get_mem h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rw [h.mem_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "have := Part.get_mem h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rw [Part.get_eq_get]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rw [h.dom_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "convert Part.get_mem _ _"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rw [h.unique h.toDom]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "simp only [Part.get_mem]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "have h := Part.get_mem _ _"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rw [Part.get_eq_get h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "have h := Part.get_mem _"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rw [h.get_eq]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rfl"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rw [Part.get_eq]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "haveI := h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rw [\u2190 o.eq_of_dom _]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rw [\u2190 o.eq_of_dom h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rw [h.eq_of_dom h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rw [h.unique h.get]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rw [Part.get_mem]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "have h := Part.get_mem _ h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "convert Part.mem_univ o"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rw [h.unique h.choose_spec]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rw [h.unique h.dom]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "convert Part.mem_get o h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "have h := Part.get_mem o"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "have := h.to_finite"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rw [Part.dom_iff_mem]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rw [h.eq_get]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "simp"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "convert Part.get_mem _ h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "convert Part.mem_get h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rw [h.get_mem]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rw [\u2190 o.eq_of_mk_mem h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rw [\u2190 o.eq_get_of_dom h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "convert Part.mem_unique Part.get_mem h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "have := Part.get_mem _ h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rw [\u2190 o.get_to_eq]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "have := Part.get_mem _ _"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "convert Part.mem_unique (\u03b1 := Part \u03b1) h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rw [\u2190 o.eq_of_mem h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rw [h.eq_mk]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "have := Part.get_mem o"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rw [\u2190 o.get_mem]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "have := h.mem"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rw [\u2190 Part.get_mem]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "haveI := h.to_subtype"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rw [Part.mem_get_iff]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rw [\u2190 o.eq_of_dom _, Part.get_mem]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "convert @Part.get_mem _ o.Dom _"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rw [h.head_mem]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "have := Part.get_mem _"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "rw [\u2190 o.eq_some_iff_mem]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : o.Dom\n\u22a2 get o h \u2208 o", "positive": "cases o", "negative": "by_cases ho : o.Dom"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only at h"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "trivial"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "aesop"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only only at h"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only at h \u22a2"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only [Prod.mk.inj_iff]"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only [Dom.mk.inj_iff]"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "cases h"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "rfl"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "aesop (rule_sets [Sym2])"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "exact h"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "rw [Part.mem_mk_iff] at h"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "apply Sigma.mk.inj_iff.1"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "try assumption"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "apply Sigma.mk.inj_iff"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only only at h \u22a2"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "rw [Part.mem_mk_iff_get] at h"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "try aesop"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only [Prod.mk.inj_iff] at h"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only [Sigma.mk.inj_iff]"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "rw [PMF.mk_mem_get]"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "rw [Prod.mk.inj_iff]"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "apply Dom.mk.inj_iff"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "exact h.symm"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "rw [Part.mem_mk_iff]"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "rw [Part.mk.inj_iff]"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only [FreeGroup.mk.inj_iff]"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only [Prod.mk.inj_iff, eq_self_iff_true]"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only constructor"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only [Part.mem_mk_iff] at h"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "constructor <;> try assumption"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "apply Dom.mk_mem_get"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only at *"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "apply Sigma.Mk.inj_iff.1"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only [true_and]"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "aesop (rule_sets [Sym2]) (add norm unfold [Quotient.rec, Quot.rec])"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only [Dom.mk.inj_iff] at h"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "apply Part.mk.inj"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only [forall_prop_of_true] at h"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "constructor <;> exact h"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only [Prop.mk.inj_iff]"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only only [Dom.mk.inj_iff]"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only of_dom h"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only [Mathlib.Tactic.Abel.get, true_and]"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only [Prod.mk.inj_iff, Prod.mk.injEq, heq_eq_eq, true_and]"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "apply Sigma.Mk.inj"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "apply Prop.mk.inj_iff"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only [Part.mem_mk_iff, Prod.mk.injEq, heq_eq_eq, true_and]"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only [Prod.mk.inj_iff, eq_self_iff_true, heq_iff_eq]"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only of_dom"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only only [Dom.mk.inj_iff, heq_eq_eq, Prod.mk.injEq, true_and]"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "apply Dom.mk_mem_mk"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only only [Prod.mk.inj_iff, eq_self_iff_true]"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only [Mathlib.Tactic.Abel.get, eq_self_iff_true, heq_iff_eq, mk.injEq]"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "apply Part.mem_mk_iff_get.2"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "apply Prop.mk.inj_iff.1"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only only [true_and]"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "simp only [FreeGroup.mk.inj_iff] at h"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "rw [Part.mem_mk_iff_get]"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "rintro \u27e8\u27e9"}, {"state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } h \u2208 { Dom := Dom\u271d, get := get\u271d }", "positive": "constructor", "negative": "apply Prod.mk.inj_iff.1"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.mk.inj_iff"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.ext"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "Rfl"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.Mk.inj_iff"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "assumption"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.ext_iff.2"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.eq"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply h"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.mk.inj_iff.2"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "aesop (rule_sets [Sym2])"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sym2.eq_of_heq"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "simp only [Prod.mk.inj_iff]"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.Fix.get_mk"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "simp only [Sigma.mk.inj_iff]"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.Function.get_mk_eq"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.Embedding.get_mk"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.mk.inj_iff.1"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.ext'"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.Equiv.injective h"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.Function.mk_eq_mk"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.Mk.inj_iff.2"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.Mk.inj_iff.1"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.eq_of_heq"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.Get.heq"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.eta"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.Embedding.get_mk_inj"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.Fun.mk_eq_mk"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.Embedding.get_mk_eq"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.heq_of_eq"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.Fix.get_fst_fst"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.Get.mk_eq_mk"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.Fix.get_mk_inj"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "simp only [Part.mk.inj_iff]"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "simp only [Sigma.mk.inj_iff, heq_eq_eq]"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply eq_of_heq"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Get.mk.inj"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.Function.mk.inj_iff"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.Fun.mk_eq"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "aesop (rule_sets [Sym2]) h"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "simp only [Sigma.mk.inj_iff, heq_iff_eq]"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "aesop (rule_sets [Sym2]) (add norm unfold [Quotient.rec, Quot.rec])"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.Func.get_mk"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.Embedding.get_mk h"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.Fin.get_mk_inj"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "simp only [Prod.mk.inj_iff, heq_eq_eq]"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.Fin.get_mk"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.FinMap.heq"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.Form.get_mk_inj"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.Func.get_mk_inj"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.Fun.mk_eq_mk_iff.2"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Prod.ext"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.get_mk_inj"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.Function.get_mk"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.Function.hfunext"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.Embedding.get_mk_inj h"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.mk.inj"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.mk.inj_right"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.Embedding.get"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.Embedding.get_map"}, {"state": "case mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 get { Dom := Dom\u271d, get := get\u271d } ?mk.w = get { Dom := Dom\u271d, get := get\u271d } h\n\ncase mk.w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nDom\u271d : Prop\nget\u271d : Dom\u271d \u2192 \u03b1\nh : { Dom := Dom\u271d, get := get\u271d }.Dom\n\u22a2 { Dom := Dom\u271d, get := get\u271d }.Dom", "positive": "rfl", "negative": "apply Sigma.FormalMk.injective h"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_mul]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, RingHom.map_mul]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_map]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "simp only [Algebra.smul_def, RingHom.map_mul]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, RingHom.map_mul, Algebra.smul_def]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_apply]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, RingHom.map_mul, RingHom.map_mul, IsLocalization.map_eq]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, Algebra.smul_def]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "simp"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, RingHom.map_mul, RingHom.map_mul]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, map_mul, IsLocalization.map_map]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, IsLocalization.map_map]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "simp_rw [Algebra.smul_def, RingHom.map_mul]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq, RingHom.map_mul]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, IsLocalization.map_map, Algebra.smul_def]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, IsLocalization.map_apply]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "simp_rw [Algebra.smul_def]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, map_mul, IsLocalization.map_mul]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_algebraMap]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, IsLocalization.map_apply, Algebra.smul_def]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, map_mul, IsLocalization.map_eq]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [\u2190 (IsLocalization.map Q g hy).RingHom.map_smul, Algebra.smul_def]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, IsLocalization.map_eq]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_apply, IsLocalization.map_eq]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, IsLocalization.map_mul]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_apply]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "simp [IsLocalization.map_smul]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "simp only [Algebra.smul_def]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, Algebra.smul_def, RingHom.map_mul]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "simp only [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_apply]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "simp_rw [\u2190 IsLocalization.map_smul, Algebra.smul_def]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq, IsLocalization.map_eq]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq, RingHom.map_mul]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, map_mul]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_mul, IsLocalization.map_mul]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [SMulHomClass.map_smul, Algebra.smul_def]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.eq_map_mul]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "simp_rw [Algebra.smul_def, RingHom.map_mul, RingHom.map_mul]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq, RingHom.map_mul, IsLocalization.map_eq]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, IsLocalization.map_apply, map_mul]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "simp_rw [Algebra.smul_def, RingHom.map_mul, Algebra.smul_def]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, Algebra.smul_def, IsLocalization.map_map]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq T g hy]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "simp only [map_smul, Algebra.smul_def]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, RingHom.map_mul, map_mul, IsLocalization.map_eq]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq T _ hy]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_apply, Algebra.smul_def]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, IsLocalization.map_map, RingHom.map_mul]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, IsLocalization.map_map, map_mul]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "simp only [Algebra.smul_def, RingHom.map_mul, RingHom.map_mul]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "simp only [Algebra.smul_def, RingHom.map_mul, Algebra.smul_def]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, RingHom.map_mul, \u2190 IsLocalization.map_mul]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, Algebra.smul_def, IsLocalization.map_apply]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq_map_mul]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, IsLocalization.map_apply, map_mul, IsLocalization.map_eq]"}, {"state": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : { x // x \u2208 M }), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nx : S\nz : R\n\u22a2 \u2191(map Q g hy) (z \u2022 x) = \u2191g z \u2022 \u2191(map Q g hy) x", "positive": "simp_rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_eq]", "negative": "rw [Algebra.smul_def, RingHom.map_mul, IsLocalization.map_apply _ _ hy]"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "rw [EMetric.diam_image]"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine ENNReal.le_of_forall_pos_le_add fun \u03b5 \u03b50 =>?_"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine ENNReal.le_of_forall_pos_le_add fun \u03b5 \u03b5pos =>?_"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine (EMetric.diam_le_iff.1 hd).LE.le.trans?_"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine le_trans EMetric.diam_mono?_"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "rcases eq_or_ne C 0 with (rfl | hC)"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "rcases ENNReal.eq_zero_or_pos C with (rfl | hC)"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine (EMetric.diam_le fun x hx y hy => hf.edist_le hx hy).LE.le.trans?_"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine ENNReal.le_of_forall_pos_le_add fun \u03b5 \u03b5pos h\u03b5 =>?_"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine (hf.ediam_image_inter_le _).LE.le.trans?_"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "rw [\u2190 ENNReal.coe_le_coe] at hd \u22a2"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine (EMetric.diam_mono fun x hx y hy => hf.edist_le hx hy).LE.le.trans?_"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine le_trans (EMetric.diam_mono?_) (ENNReal.rpow_le_rpow hd ENNReal.coe_nonneg)"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine le_trans (EMetric.diam_mono fun x hx y hy => hf.edist_le hx hy)?_"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine le_trans (hf.ediam_image_inter_le _)?_"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine' le_trans EMetric.diam_mono fun x hx y hy => _"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine le_trans (EMetric.diam_mono?_) (ENNReal.rpow_le_rpow hd ENNReal.coe_ne_top)"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine (EMetric.diam_le_iff.1 hd).LE.le.trans_eq?_"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "apply ENNReal.le_of_forall_pos_le_add"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "rcases eq_or_ne C 0 with (rfl | hC0)"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine' le_trans (EMetric.diam_mono fun x hx y hy => _) (ENNReal.rpow_le_rpow hx hy)"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine (EMetric.diam_le_iff.2 fun x hx y hy => hf.edist_le hx hy).LE.le.trans?_"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "rcases eq_or_ne t 0 with (rfl | ht)"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine (EMetric.diam_le_iff.2 fun a ha b hb =>?_).LE.le.trans?_"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "rcases ENNReal.eq_or_lt_of_le hd with (rfl | hd)"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine le_trans?_ (EMetric.diam_mono?_)"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "rw [EMetric.diam_le_iff] at hd \u22a2"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine le_trans (EMetric.diam_mono?_) (ENNReal.rpow_le_rpow hd (ENNReal.coe_nonneg _))"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine le_trans (EMetric.diam_le fun x hx y hy => hf.edist_le hx hy)?_"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine EMetric.diam_le fun x hx y hy =>?_"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "simp only [EMetric.diam_image]"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine le_trans EMetric.diam_mono fun x hx y hy =>?_"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "rw [\u2190 ENNReal.coe_tsum]"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine (hf.ediam_image_inter_le _ _).LE.le.trans?_"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine (EMetric.diam_le_iff.2 fun x hx y hy => hf hx hy).LE.le.trans?_"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine (EMetric.diam_le fun x hx y hy => hf.edist_le hx hy).LE.le.trans_eq?_"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine' ENNReal.le_of_forall_pos_le_add fun \u03b5 \u03b50 => _"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "rw [\u2190 EMetric.diam_compl]"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "rw [\u2190 EMetric.diam_coe]"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine (EMetric.diam_le fun x hx y hy => hf.ediam_image_inter_le hx hy).LE.le.trans?_"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "rw [\u2190 EMetric.diam_const]"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine le_trans (EMetric.diam_mono?_) (le_trans hd?_)"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine (EMetric.diam_le fun x hx y hy => hf.ediam_le hx hy).LE.le.trans?_"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine le_trans (EMetric.diam_mono?_) ENNReal.coe_le_coe"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "exact (hf.ediam_image_inter_le _).LE.le.trans (ENNReal.rpow_le_rpow hd ENNReal.coe_ne_top)"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine (EMetric.diam_le_iff.2 fun a ha b hb =>?_).LE.le.trans ENNReal.rpow_le_rpow"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine le_trans?_ (ENNReal.rpow_le_rpow hd ENNReal.coe_nonneg)"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine (EMetric.diam_mono?_).LE.le.trans ENNReal.rpow_le_rpow"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hd with \u27e8r, hr, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "rw [EMetric.diam_image_iff]"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine (EMetric.diam_le fun x hx y hy => hf hx hy).LE.le.trans?_"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine le_trans (EMetric.diam_mono?_) (ENNReal.rpow_le_rpow?_ ENNReal.coe_nonneg)"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine (EMetric.diam_mono fun x hx y hy => hf.edist_le hx hy).LE.le.trans_eq?_"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine' le_trans (EMetric.diam_mono fun x hx y hy => _) (ENNReal.rpow_le_rpow hx (ENNReal.coe_nonneg _))"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine (EMetric.diam_le_iff.2 fun x hx y hy => hf.edist_le hx hy).LE.le.trans_eq?_"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine' le_trans (EMetric.diam_mono fun x hx y hy => hf.edist_le hx hy) _"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine' (EMetric.diam_le fun x hx y hy => hf.edist_le hx hy).LE.le.trans _"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine le_trans (EMetric.diam_mono?_) (ENNReal.mul_le_of_le_div' hd)"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine (ENNReal.tsum_le_tsum fun x hx y hy => hf.edist_le hx hy).LE.le.trans?_"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine (EMetric.diam_le_iff.2 fun a ha b hb =>?_).LE.le.trans_eq?_"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine' le_trans (EMetric.diam_le fun x hx y hy => _) (ENNReal.rpow_le_rpow hx hy)"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine (EMetric.diam_mono?_).LE.le.trans (ENNReal.rpow_le_rpow hd ENNReal.coe_ne_top)"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 EMetric.diam (f '' (t \u2229 s)) \u2264 \u2191C * d ^ \u2191r", "positive": "rw [EMetric.diam_le_iff]", "negative": "refine' le_trans (EMetric.diam_mono _) (ENNReal.rpow_le_rpow hd ENNReal.coe_ne_top)"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, hz, rfl\u27e9 _ \u27e8x, hx, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, hz, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8x\u2081, hx\u2081, rfl\u27e9 _ \u27e8x\u2082, hx\u2082, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8x', hx', rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8x', hx', rfl\u27e9 _ \u27e8y', hy', rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, hzs, rfl\u27e9 _ \u27e8x, hx, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8y, hy, rfl\u27e9 _ \u27e8z, hz, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, hzt, rfl\u27e9 _ \u27e8x, hx, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8x, \u27e8hx, rfl\u27e9, y, \u27e8hy, rfl\u27e9, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, hz, rfl\u27e9 _ \u27e8x', hx', rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8a, ha, rfl\u27e9 _ \u27e8b, hb, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8z, hz, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8x\u2081, hx\u2081, rfl\u27e9 _ \u27e8y\u2082, hy\u2082, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, hys\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8y, hy, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, hy'\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8y, hy, rfl\u27e9 _ \u27e8z, hzs, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, hzs, rfl\u27e9 _ \u27e8y, hyt, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, zt, rfl\u27e9 _ \u27e8x, hx, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8x\u2081, hx\u2081, rfl\u27e9 _ \u27e8x\u2082, hx\u2082, hx\u2082\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, hzt, rfl\u27e9 _ \u27e8y, hyt, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, hz, rfl\u27e9 _ \u27e8w, hw, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, \u27e8hxt, hzs\u27e9, rfl\u27e9 _ \u27e8y, hyt, hys\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8_, \u27e8x, hx, rfl\u27e9, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8x, hxs, rfl\u27e9 _ \u27e8y, hyt, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8z, hzs, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, hz, rfl\u27e9 _ \u27e8-, hzs, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, \u27e8hx, rfl\u27e9\u27e9 _ \u27e8y, hy, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, hzt, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, \u27e8hx, rfl\u27e9, hyz\u27e9 _ \u27e8y, hy, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, hz, rfl\u27e9 _ \u27e8z, hz, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8x, _, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8x, hx y hy, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8x, y, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, hxy\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, \u27e8hxt, hzs\u27e9, rfl\u27e9 _ \u27e8x, hxt, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8x', hx', rfl\u27e9 _ \u27e8x', hx', rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8x\u2081, hx\u2081, rfl\u27e9 _ \u27e8x\u2082, hx\u2082, hx\u2082, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, zt, hxy, rfl\u27e9 _ \u27e8x, hx, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, hzs, rfl\u27e9 _ \u27e8y, hys, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, hzt, rfl\u27e9 _ \u27e8y, hys, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, \u27e8hx, rfl\u27e9, hzs\u27e9 _ \u27e8y, hy, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8x, hx : x \u2208 s, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, hz, rfl\u27e9 _ \u27e8x, hxs, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8_, \u27e8x, hx, rfl\u27e9, rfl\u27e9 _ \u27e8x', hx', rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, \u27e8hzt, rfl\u27e9, hyz\u27e9 _ \u27e8y, hyt, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8x, \u27e8hxs, rfl\u27e9, y, \u27e8hyt, rfl\u27e9, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, zt, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8x, \u27e8hx, rfl\u27e9, y, \u27e8hy, rfl\u27e9\u27e9 _ \u27e8y, \u27e8hy, rfl\u27e9, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, \u27e8hxz, rfl\u27e9, hyz\u27e9 _ \u27e8y, hys, hyz\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8x, \u27e8hxs, rfl\u27e9, y, \u27e8hys, rfl\u27e9, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8x\u2081, hx\u2081, hx\u2082\u27e9 _ \u27e8x\u2082, hx\u2082, hx\u2082\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, \u27e8hzt, rfl\u27e9, hzs\u27e9 _ \u27e8x, hx, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8x, \u27e8hx, rfl\u27e9, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8x, \u27e8hxt, hxs\u27e9, rfl\u27e9 _ \u27e8y, hyt, hys\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, \u27e8hzt, rfl\u27e9, hzs\u27e9 _ \u27e8y, hyt, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, \u27e8hxz, rfl\u27e9, hyz\u27e9 _ \u27e8y, hys, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, \u27e8hzt, rfl\u27e9, hyz\u27e9 _ \u27e8x, hx, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro x \u27e8xt, xs, rfl\u27e9 y \u27e8yt, yt, hyt, rfl\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, \u27e8hx, rfl\u27e9\u27e9 _ \u27e8y, \u27e8hy, rfl\u27e9\u27e9"}, {"state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\n\u22a2 \u2200 (x : Y), x \u2208 f '' (t \u2229 s) \u2192 \u2200 (y : Y), y \u2208 f '' (t \u2229 s) \u2192 edist x y \u2264 \u2191C * d ^ \u2191r", "positive": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9", "negative": "rintro _ \u27e8z, \u27e8hxt, hzs\u27e9, rfl\u27e9 _ \u27e8y, hyt, rfl\u27e9"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact hf.edist_le_of_le hx hy hxy"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "apply hf.edist_le_of_le hx hy"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact hf.edist_le_of_le hx hy.2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact hf.edist_le_of_le hx hy"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact hf.edist_le_of_le hx hy.1 hx.2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "apply HolderOnWith.edist_le_of_le"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact hf.edist_le_of_le hx hy.1 hy.2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "apply ENNReal.le_of_forall_pos_le_add"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact hf hx hy hxy"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact hf hx hy"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact hf.edist_le_of_le hx hy.1 hx.2 hy.2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact hf.edist_le_of_le hx.1 hy.2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact hf.edist_le_of_le hx hy hxy hy"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "rw [edist_dist]"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "apply hf.edist_le_of_le hx.1 hy.2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "rw [PseudoEMetricSpace.edist_comm]"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact hf.edist_le_of_le hx.2 hy.2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "rw [Set.inter_comm] at hx hy"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "apply hf.edist_le_of_le hx hy.2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact hf.edist_le_of_le hx hy.1 hx hy.2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact hf.edist_le_of_le hx.2 hy.1 hx.2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "apply hf.edist_le_of_le"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "rw [Set.inter_comm] at *"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact hf hx.2 hy.2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact hf.edist_le_of_le hx hy hy"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact hf.edist_le_of_le hx.1 hy.1 hx.2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact hf.edist_le_of_le hx hy hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "apply HolderOnWith.edist_le_of_le _ hf hx.2 hy.2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "apply HolderOnWith.edist_le_of_le _ hf hx.1 hy.2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact hf.edist_le_of_le hx hy h"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "apply HolderOnWith.edist_le_of_le_geometric"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact hf hx hy y hy"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact hf.edist_le_of_le hx.1 hy.2 hx.2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "apply hf.edist_le_of_le hx hy.1"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact hf hx hy hy"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "apply HolderOnWith.edist_le_of_le _ hf"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact hf.edist_le_of_le hx hy hx hy"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact hf.edist_le_of_le hx hy hx.2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "rw [edist_dist, ENNReal.coe_le_coe]"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact hf.edist_le_of_le hx.2 hy.1 hx.2 hy.2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact hf hx.2 hy.1 hx.2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "apply HolderOnWith.edist_le_of_le _ hf hx hy"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "apply HolderOnWith.edist_le_of_le_rpow"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact HolderOnWith.edist_le_of_le hf hx.1 hy.2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "apply HolderOnWith.edist_le_of_le hf hx.1 hy.2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact HolderOnWith.edist_le_of_le hf hx.2 hy.2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "rcases hx with \u27e8hxt, hxy\u27e9"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "apply HolderOnWith.edist_le_of_le_coe"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact HolderOnWith.edist_le_of_le hf hx hy"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "apply HolderOnWith.edist_le_of_le hf hx hy"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact hf.edist_le_of_le hx.1 hy.1 hx.2 hy.2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "apply HolderOnWith.edist_le_of_le_geometric_coe"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact hf.edist_le_of_le hx hy.2 hxy"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "rw [Set.inter_comm]"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "apply hf.edist_le_of_le hx.2 hy.1"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact hf.edist_le_of_le hx.1 hy.2 hx.2 hy.2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "rw [edist_nndist]"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "apply HolderOnWith.edist_le_of_le_geometric''"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "rw [PseudoEMetricSpace.edist_self]"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "exact hf hx hy hxy hy"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "apply hf.edist_le_of_le hx.2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist (f x) (f y) \u2264 \u2191C * d ^ \u2191r", "positive": "apply hf.edist_le_of_le hx.2 hy.2", "negative": "apply HolderOnWith.edist_le_of_le _ _ hf"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "rw [PseudoEMetricSpace.edist_comm]"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "rwa [PseudoEMetricSpace.edist_comm]"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact le_trans (EMetric.edist_le_diam_of_mem hx hy) hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact le_trans (EMetric.edist_le_diam_of_mem hx hy.1) hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "rw [Set.inter_comm] at hx hy"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "rwa [Set.inter_comm] at hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact le_trans (EMetric.edist_le_diam_of_mem hx.2 hy.2) hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact le_trans (EMetric.edist_le_diam_of_mem hx hy.2) hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact le_trans (EMetric.edist_le_diam_of_mem hx.2 hy.1) hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.2) hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "rw [Set.inter_comm] at hx hy \u22a2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "rwa [Set.inter_eq_self_of_subset_right hx.2, PseudoEMetricSpace.edist_comm]"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact EMetric.edist_le_diam_of_mem hx hy"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact (EMetric.edist_le_diam_of_mem hx hy).LE.le.trans hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "rwa [Set.inter_comm, PseudoEMetricSpace.edist_comm]"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact EMetric.edist_le_diam_of_mem hx hy hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "rw [edist_dist]"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact EMetric.edist_le_diam_of_mem hx hy.2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "rwa [Set.inter_comm]"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact le_trans hx.2 hy.2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact le_trans (EMetric.diam_mono hx.2 hy.1) hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "rwa [Set.inter_self, PseudoEMetricSpace.edist_comm]"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact EMetric.edist_le_of_mem_diam hx hy"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact EMetric.edist_le_of_mem hx hy.1 hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "rw [Set.inter_comm] at hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact EMetric.edist_le_of_mem hx hy"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact EMetric.edist_le_of_mem hx hy.2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact EMetric.edist_le_diam_of_mem hx hy.1 hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact (EMetric.edist_le_diam_of_mem hx hy.1).LE.le.trans hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact le_trans (EMetric.edist_le_diam_of_mem hx hy hd) hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "rwa [Set.inter_eq_self_of_subset_right hx.2, Set.inter_eq_self_of_subset_right hd]"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact EMetric.edist_le_of_mem_diam hx hy hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact EMetric.diam_le_of_mem \u27e8hx.1, hy.1\u27e9 hy.2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact le_trans (EMetric.diam_mono hx.1 hy.1) hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact (EMetric.diam_mono hx.2 hy.1).LE.le.trans hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "rw [PseudoEMetricSpace.edist_comm x y] at hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact le_trans (EMetric.diam_mono hx.2 hy.2) hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact le_trans (EMetric.diam_mono hx.1 hy.2) hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact edist_le_of_mem_diam hx hy"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "rw [PseudoEMetricSpace.edist_comm] at hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact (EMetric.edist_le_diam_of_mem hx.1 hy.1).LE.le.trans hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "rwa [Set.inter_eq_self_of_subset_right hx.2] at hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact EMetric.edist_le_of_mem_diam hx hy.1 hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact (EMetric.edist_le_diam_of_mem hx hy.2).LE.le.trans hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact EMetric.edist_le_of_mem_diam hx hy.2"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact EMetric.edist_le_of_mem hx hy hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact (EMetric.edist_le_diam_of_mem hx.2 hy.1).LE.le.trans hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact (EMetric.edist_le_diam_of_mem hx.2 hy.2).LE.le.trans hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact (EMetric.diam_mono hx.2 hy.2).LE.le.trans hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "rw [PseudoEMetricSpace.edist_comm x y]"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact (EMetric.edist_le_diam_of_mem hx.1 hy.2).LE.le.trans hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "rw [\u2190 EMetric.diam_image]"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "rwa [Set.inter_eq_self_of_subset_right hx.2, EMetric.edist_le_infEdist]"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "rwa [Set.inter_eq_self_of_subset_right hx.2, edist_dist]"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact (EMetric.diam_mono hx.1 hy.1).LE.le.trans hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact EMetric.diam_le_of_mem hx hy"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "rw [PseudoEMetricSpace.edist_comm x]"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact le_trans (edist_le_diam_of_mem hx hy) hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "rwa [Set.inter_eq_self_of_subset_right hx.2, EMetric.diam_le_iff]"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "rw [\u2190 PseudoEMetricSpace.edist_comm]"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "rwa [Set.inter_eq_self_of_subset_right hx.2, PseudoEMetricSpace.edist_comm x y]"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "exact (EMetric.diam_mono hx.1 hy.2).LE.le.trans hd"}, {"state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace X\ninst\u271d\u00b9 : PseudoEMetricSpace Y\ninst\u271d : PseudoEMetricSpace Z\nC r : \u211d\u22650\nf : X \u2192 Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : \u211d\u22650\u221e\nhd : EMetric.diam t \u2264 d\nx : X\nhx : x \u2208 t \u2229 s\ny : X\nhy : y \u2208 t \u2229 s\n\u22a2 edist x y \u2264 d", "positive": "exact le_trans (EMetric.edist_le_diam_of_mem hx.1 hy.1) hd", "negative": "rwa [Set.inter_eq_self_of_subset_right hx.2, EMetric.diam_eq_self hy.2] at hd"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.hom_inv_id, CategoryTheory.MonoidalCategory.comp_tensor_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.id_tensor_comp]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.Category.comp_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.hom_inv_id, CategoryTheory.Category.comp_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.tensor_comp]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.hom_inv_id, CategoryTheory.MonoidalCategory.id_tensor_comp]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.tensor_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id_assoc]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id_assoc, CategoryTheory.MonoidalCategory.comp_tensor_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.IsIso.hom_inv_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, \u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id, CategoryTheory.IsIso.hom_inv_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, \u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.hom_inv_id, CategoryTheory.MonoidalCategory.comp_tensor_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.hom_inv_id, CategoryTheory.MonoidalCategory.tensor_comp]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id, CategoryTheory.IsIso.inv_hom_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.associator_naturality]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.Iso.hom_inv_id, CategoryTheory.MonoidalCategory.comp_tensor_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id_assoc, CategoryTheory.IsIso.hom_inv_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.IsIso.inv_hom_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, \u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.hom_inv_id, CategoryTheory.Category.comp_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id, CategoryTheory.MonoidalCategory.comp_tensor_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id_assoc, CategoryTheory.MonoidalCategory.id_tensor_comp]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id_assoc, CategoryTheory.IsIso.inv_hom_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.tensor_id_comp_id_tensor]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.hom_inv_id, CategoryTheory.MonoidalCategory.tensor_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.Category.assoc]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [CategoryTheory.IsIso.eq_inv_comp, CategoryTheory.MonoidalCategory.comp_tensor_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [CategoryTheory.IsIso.eq_comp_inv f, \u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.hom_inv_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, \u2190 CategoryTheory.MonoidalCategory.tensor_comp]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id, CategoryTheory.MonoidalCategory.id_tensor_comp]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, \u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.id_tensor_comp]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id_assoc, CategoryTheory.Category.comp_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.hom_inv_id, CategoryTheory.MonoidalCategory.comp_tensor_id, CategoryTheory.IsIso.inv_hom_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [CategoryTheory.IsIso.eq_inv_comp, CategoryTheory.MonoidalCategory.tensor_comp]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, \u2190 CategoryTheory.MonoidalCategory.comp_tensor_id, CategoryTheory.IsIso.hom_inv_id, CategoryTheory.MonoidalCategory.comp_tensor_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, \u2190 CategoryTheory.MonoidalCategory.tensor_comp]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.Iso.hom_inv_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.Iso.inv_hom_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, \u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.hom_inv_id, CategoryTheory.IsIso.inv_hom_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [CategoryTheory.IsIso.eq_comp_inv f, CategoryTheory.MonoidalCategory.tensor_comp]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id, CategoryTheory.Category.comp_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [CategoryTheory.IsIso.eq_comp_inv, CategoryTheory.MonoidalCategory.tensor_comp]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.hom_inv_id, CategoryTheory.MonoidalCategory.comp_tensor_id, CategoryTheory.MonoidalCategory.comp_tensor_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id, CategoryTheory.MonoidalCategory.tensor_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.id_tensor_comp, CategoryTheory.IsIso.hom_inv_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id_assoc, CategoryTheory.MonoidalCategory.tensor_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id, CategoryTheory.Category.assoc]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.hom_inv_id_assoc]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, \u2190 CategoryTheory.IsIso.hom_inv_id, CategoryTheory.MonoidalCategory.comp_tensor_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, \u2190 CategoryTheory.MonoidalCategory.comp_tensor_id, CategoryTheory.IsIso.hom_inv_id, CategoryTheory.Category.comp_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.Category.id_comp]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, \u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.hom_inv_id, CategoryTheory.MonoidalCategory.comp_tensor_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id_assoc, CategoryTheory.IsIso.hom_inv_id, CategoryTheory.MonoidalCategory.comp_tensor_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.hom_inv_id, CategoryTheory.MonoidalCategory.associator_naturality]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, \u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.hom_inv_id, CategoryTheory.MonoidalCategory.id_tensor_comp]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.Iso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]"}, {"state": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b3 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nU V\u271d W\u271d X\u271d Y\u271d Z\u271d V W X Y Z : C\nf : V \u27f6 W\ninst\u271d : IsIso f\ng : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "positive": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, CategoryTheory.IsIso.inv_hom_id, CategoryTheory.MonoidalCategory.comp_tensor_id]", "negative": "rw [\u2190 CategoryTheory.MonoidalCategory.tensor_comp, \u2190 CategoryTheory.MonoidalCategory.comp_tensor_id, CategoryTheory.IsIso.hom_inv_id]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_coe, NonUnitalStarSubalgebra.coe_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_coe, NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 SetLike.mem_coe, NonUnitalStarSubalgebra.coe_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_coe_toNonUnitalSubalgebra, NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra, NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_coe_star, NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_coe_iff, NonUnitalStarSubalgebra.coe_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_coe, NonUnitalStarSubalgebra.mem_coe]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_coe_star, NonUnitalStarSubalgebra.mem_coe_star]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_coe_subalgebra, NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [S.toNonUnitalSubalgebra.mem_iff]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra, NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 SetLike.mem_coe, S.coe_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_coe_nonUnitalSubalgebra, NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.coe_toNonUnitalSubalgebra S, NonUnitalStarSubalgebra.mem_coe_subalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_coe_iff, NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_coe_toNonUnitalSubalgebra, NonUnitalStarSubalgebra.mem_coe_star]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [NonUnitalStarSubalgebra.mem_coe, NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.coe_toNonUnitalSubalgebra, NonUnitalStarSubalgebra.mem_coe_star]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_coe_subalgebra, NonUnitalStarSubalgebra.mem_coe_subalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.coe_toNonUnitalSubalgebra S, NonUnitalStarSubalgebra.mem_coe_star]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [S.coe_toNonUnitalSubalgebra, NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.coe_toNonUnitalSubalgebra, NonUnitalStarSubalgebra.mem_coe_subalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [S.toNonUnitalSubalgebra, NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_coe_iff, NonUnitalStarSubalgebra.mem_coe_iff]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.coe_toNonUnitalSubalgebra, NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_coe_star, NonUnitalStarSubalgebra.coe_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_coe_toNonUnitalSubalgebra, NonUnitalStarSubalgebra.mem_coe_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.coe_toNonUnitalSubalgebra S, NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.coe_toNonUnitalSubalgebra S, NonUnitalStarSubalgebra.coe_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_coe_toNonUnitalSubalgebra, NonUnitalStarSubalgebra.mem_coe_subalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.coe_toNonUnitalSubalgebra S, NonUnitalStarSubalgebra.mem_coe]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_coe_subalgebra, NonUnitalStarSubalgebra.coe_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [S.mem_toNonUnitalSubalgebra, NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.coe_toNonUnitalSubalgebra, NonUnitalStarSubalgebra.mem_coe]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_coe, NonUnitalStarSubalgebra.mem_coe, NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_coe, NonUnitalStarSubalgebra.mem_coe_star]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_coe_toNonUnitalSubalgebra S, NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [NonUnitalStarSubalgebra.mem_coe_iff, NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [S.coe_toNonUnitalSubalgebra, NonUnitalStarSubalgebra.mem_coe_subalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [S.coe_toNonUnitalSubalgebra, NonUnitalStarSubalgebra.mem_coe_star]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 S.mem_toNonUnitalSubalgebra, NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 SetLike.mem_coe, S.coe_toNonUnitalSubalgebra, NonUnitalStarSubalgebra.mem_coe]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [S.coe_toNonUnitalSubalgebra, NonUnitalStarSubalgebra.mem_coe]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [S.toNonUnitalSubalgebra.mem_iff, NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_coe, NonUnitalStarSubalgebra.mem_coe_subalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 SetLike.mem_coe, S.coe_toNonUnitalSubalgebra, NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [S.mem_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_coe_toNonUnitalSubalgebra, NonUnitalStarSubalgebra.coe_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_coe_iff, NonUnitalStarSubalgebra.mem_coe_star]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_coe, S.coe_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra, NonUnitalStarSubalgebra.mem_coe_star]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [S.toNonUnitalSubalgebra.mem_iff, NonUnitalStarSubalgebra.mem_iff]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 SetLike.mem_coe, NonUnitalStarSubalgebra.coe_toNonUnitalSubalgebra, NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.coe_toNonUnitalSubalgebra S, NonUnitalStarSubalgebra.mem_coe_set_iff]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_coe, NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra, SetLike.mem_coe]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 AddMonoidHom.mem_toNonUnitalSubalgebra, NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 SetLike.mem_coe, S.coe_toNonUnitalSubalgebra, NonUnitalStarSubalgebra.coe_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.coe_toNonUnitalSubalgebra S, NonUnitalStarSubalgebra.mem_coe_iff]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_coe, NonUnitalStarSubalgebra.coe_toNonUnitalSubalgebra, SetLike.mem_coe]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_coe_star, NonUnitalStarSubalgebra.mem_coe]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_coe, NonUnitalStarSubalgebra.coe_toNonUnitalSubalgebra, NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra]"}, {"state": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : Star A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : Module R B\ninst\u271d\u2074 : Star B\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring C\ninst\u271d\u00b2 : Module R C\ninst\u271d\u00b9 : Star C\ninst\u271d : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nx : A\n\u22a2 x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "positive": "rfl", "negative": "rw [\u2190 NonUnitalStarSubalgebra.mem_coe, NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra, NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [TensorProduct.curry_apply]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, TensorProduct.lift.tmul]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, LinearMap.comp_apply]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, TensorProduct.tmul_sub]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, TensorProduct.curry_apply]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, LinearMap.comp_apply, TensorProduct.curry_apply]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, TensorProduct.Lift.tmul]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [TensorProduct.curry, TensorProduct.lift.tmul]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, LinearMap.rTensor_tmul]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, LinearMap.comp_apply, TensorProduct.lift.tmul]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, LinearMap.lTensor_tmul]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [TensorProduct.MonoidalClosed.curry, TensorProduct.lift.tmul]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, LinearMap.restrictScalars_apply]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry_apply]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, TensorProduct.tmul_smul]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, LinearMap.comp_apply, TensorProduct.tmul_sub]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [\u2190 TensorProduct.curry_apply]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, \u2190 TensorProduct.curry_apply]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [TensorProduct.curry, TensorProduct.curry_apply]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, LinearMap.comp_apply, TensorProduct.tmul_smul]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [\u2190 f.lift_apply]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, TensorProduct.lift.tprod]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, \u2190 TensorProduct.tmul_smul]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [TensorProduct.MonoidalClosed.curry, LinearMap.comp_apply]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [\u2190 TensorProduct.lift.tmul]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, \u2190TensorProduct.curry_apply]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, \u2190 TensorProduct.tmul_sub]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [TensorProduct.curry_apply, TensorProduct.curry_apply]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [TensorProduct.MonoidalClosed.curry, TensorProduct.curry_apply]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [\u2190 TensorProduct.tmul_smul]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [TensorProduct.curry, LinearMap.comp_apply]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [TensorProduct.MonoidalClosed.curry, LinearMap.comp_apply, TensorProduct.curry_apply]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, TensorProduct.tmul_sub, TensorProduct.curry_apply]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [TensorProduct.MonoidalClosed.curry, TensorProduct.tmul_sub]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [TensorProduct.MonoidalClosed.curry]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, TensorProduct.tmul_sub, TensorProduct.lift.tmul]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [TensorProduct.MonoidalClosed.curry, LinearMap.rTensor_tmul]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [LinearMap.comp_apply]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [TensorProduct.MonoidalClosed.curry, TensorProduct.Lift.tmul]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [\u2190 TensorProduct.smul_tmul']"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, \u2190 f.lift_apply]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [TensorProduct.associator_curry]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [\u2190 TensorProduct.smul_tmul', TensorProduct.curry_apply]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, LinearMap.map_smul]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [TensorProduct.curry, TensorProduct.tmul_sub]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, LinearMap.lTensor_tmul, TensorProduct.lift.tmul]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, TensorProduct.lift.tmul, TensorProduct.curry_apply]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, TensorProduct.Lift.tprod]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [TensorProduct.MonoidalClosed.curry, LinearMap.comp_apply, TensorProduct.lift.tmul]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [TensorProduct.MonoidalClosed.curry, LinearMap.lTensor_tmul]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, LinearMap.rTensor_tmul, TensorProduct.lift.tmul]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [TensorProduct.curry, LinearMap.comp_apply, TensorProduct.lift.tmul]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, TensorProduct.lift.tmul']"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, LinearMap.one_apply]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [TensorProduct.curry, LinearMap.restrictScalars_apply]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [TensorProduct.curry, LinearMap.rTensor_tmul]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [\u2190 TensorProduct.lift.tmul, TensorProduct.curry_apply]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [TensorProduct.curry, \u2190 f.lift_apply]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, \u2190TensorProduct.tmul_sub]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [TensorProduct.MonoidalClosed.curry, LinearMap.restrictScalars_apply]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [ModuleCat.MonoidalClosed.curry, \u2190TensorProduct.tmul_smul]"}, {"state": "R : Type u\ninst\u271d : CommRing R\nM N P : ModuleCat R\nf : M \u2297 N \u27f6 P\nx : \u2191M\ny : \u2191N\n\u22a2 \u2191(\u2191(MonoidalClosed.curry f) y) x = \u2191f (x \u2297\u209c[R] y)", "positive": "rfl", "negative": "rw [TensorProduct.curry_apply, LinearMap.restrictScalars_apply]"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "intro s t"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "intro s S hS"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "intro a b"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "rintro _ \u27e8a, ha, rfl\u27e9"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "rintro a b"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simpa only [\u2190 NonUnitalSubsemiring.coe_to_subsemigroup] using Subsemigroup.gc_map_comap f"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "rintro s t"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simp only [NonUnitalSubsemiring.map_eq]"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "intro s l"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simp [GaloisConnection]"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simp only [NonUnitalSubsemiring.map_eq, Subsemigroup.gc_map_comap]"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "intro s s"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simp only [SetLike.le_def]"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simpa using Subsemigroup.gc_map_comap f"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simp only [Subsemigroup.map_comap]"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "intro s f"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simpa only [\u2190 NNReal.subsemigroup_eq] using Subsemigroup.gc_map_comap f"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "intro s hs"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simpa only [\u2190 SetLike.le_def] using Subsemigroup.gc_map_comap f"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simpa only [\u2190 NonUnitalSubsemiring.coe_toSubsemiring] using Subsemigroup.gc_map_comap f"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simp only [GaloisConnection]"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simpa only [\u2190 NonUnitalRingHom.coe_toSubsemiring] using Subsemigroup.gc_map_comap f"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simpa only [NonUnitalSubsemiring.map_eq] using Subsemigroup.gc_map_comap f"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "show GaloisConnection (NonUnitalSubsemiring.map f) (NonUnitalSubsemiring.comap f)"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "intro s S hs"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simpa only [\u2190 Subsemigroup.closure_singleton_le_iff_mem] using Subsemigroup.gc_map_comap f"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "rintro _ \u27e8a, b, h\u2081, h\u2082, rfl\u27e9"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simpa only [NonUnitalRingHom.map_comap] using Subsemigroup.gc_map_comap f"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "rintro _ _"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simpa only [NonUnitalSubsemiring.coe_map] using Subsemigroup.gc_map_comap f"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simpa only [\u2190 NonUnitalSubsemiring.comap_gc] using Subsemigroup.gc_map_comap f"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simpa only [\u2190 NNReal.coe_le_coe] using Subsemigroup.gc_map_comap f"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "rw [NonUnitalSubsemiring.map_eq]"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simp only [NonUnitalSubsemiring.map_eq, Subsemigroup.comap_comap]"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simp only [NonUnitalSubsemiring.gc_map_comap]"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simpa [NonUnitalSubsemiring.map_eq] using Subsemigroup.gc_map_comap f"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "rintro S S"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simpa only [\u2190 SetLike.coe_set_eq] using Subsemigroup.gc_map_comap f"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simp only [NonUnitalSubsemiring.map_eq, Subsemigroup.closure_eq]"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "rw [\u2190 NonUnitalSubsemiring.comap_gc]"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simpa only [\u2190 NonUnitalSubsemiring.coe_to_subsemigroup] using Submonoid.gc_map_comap f"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simpa [SetLike.le_def] using Subsemigroup.gc_map_comap f"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "intro s g"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simpa only [\u2190 Subsemigroup.gc_map_comap] using Subsemigroup.gc_map_comap f"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simpa only [\u2190 NonUnitalRingHom.coe_subsemigroup] using Subsemigroup.gc_map_comap f"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simp only [NonUnitalRingHom.map_comap]"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "rintro _ \u27e8a, ha, rfl\u27e9 \u27e8b, hb, rfl\u27e9"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "show GaloisConnection (NonUnitalRingHom.map f) (NonUnitalSubsemiring.comap f)"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simpa only [NonUnitalSubsemiring.comap_eq] using Subsemigroup.gc_map_comap f"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "rintro S S hS"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simp only [NonUnitalSubsemiring.map_comap]"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simpa [NonUnitalSubsemiring.comap_eq] using Subsemigroup.gc_map_comap f"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "rintro x y"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simpa only [\u2190 NonUnitalRingHom.coe_to_subsemigroup] using Subsemigroup.gc_map_comap f"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simpa only [Subsemigroup.map_comap] using Subsemigroup.gc_map_comap f"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "rintro _ \u27e8a, ha, rfl\u27e9 _ \u27e8b, hb, rfl\u27e9 h"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simpa only [Subsemigroup.map_comap_eq] using Subsemigroup.gc_map_comap f"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simp only [GaloisConnection, Subsemigroup.map_comap]"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "intro x y"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simp only [NonUnitalSubsemiring.map_eq, NonUnitalSubsemiring.comap_comap]"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "simpa only [Subsemigroup.closure_singleton_le_iff_mem] using Subsemigroup.gc_map_comap f"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "intro s s h"}, {"state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\ninst\u271d : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\nf : F\n\u22a2 GaloisConnection (map f) (comap f)", "positive": "intro s S", "negative": "intro s t h"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa only [\u2190 NonUnitalSubsemiring.coe_to_subsemigroup] using NonUnitalSubsemiring.map_le_iff_le_comap"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa only [NonUnitalSubsemiring.map_eq] using NonUnitalSubsemiring.map_le_iff_le_comap"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa using (NonUnitalSubsemiring.map_le_iff_le_comap f).Iff.symm"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa using (NonUnitalSubsemiring.map_le_iff_le_comap (R := R) (S := S)).Iff.symm"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa [\u2190 NonUnitalSubsemiring.coe_to_subsemigroup] using NonUnitalSubsemiring.map_le_iff_le_comap"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa only [\u2190 NonUnitalSubsemiring.coe_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa only [\u2190 NonUnitalSubsemiring.coe_to_subsemigroup, NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa only [\u2190 NonUnitalSubsemiring.coe_le] using NonUnitalSubsemiring.map_le_iff_le_comap"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa only [NonUnitalSubsemiring.le_iff_comap] using NonUnitalSubsemiring.map_le_iff_le_comap"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa only [\u2190 NonUnitalSubsemiring.coe_to_subsemigroup, NonUnitalSubsemiring.coe_map] using NonUnitalSubsemiring.map_le_iff_le_comap"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa only [\u2190 NonUnitalSubsemiring.coe_to_subsemigroup] using (NonUnitalSubsemiring.map_le_iff_le_comap f).Iff.symm"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa only [\u2190 NonUnitalSubsemiring.coe_to_subsemigroup f] using NonUnitalSubsemiring.map_le_iff_le_comap"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "constructor <;> intro h"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa [\u2190 NonUnitalSubsemiring.coe_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa using (NonUnitalSubsemiring.map_le_iff_le_comap (R := R) s).Iff.symm"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa only [\u2190 NonUnitalSubsemiring.coe_to_subsemigroup] using (NonUnitalSubsemiring.map_le_iff_le_comap (R := R) (S := S)).Iff.symm"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa only [NonUnitalSubsemiring.map_comap] using NonUnitalSubsemiring.map_le_iff_le_comap"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa only [\u2190 NonUnitalSubsemiring.coe_to_subsemigroup, NonUnitalSubsemiring.comap_map] using NonUnitalSubsemiring.map_le_iff_le_comap"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa only [\u2190 NonUnitalSubsemiring.map_comap] using NonUnitalSubsemiring.map_le_iff_le_comap"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa only [NonUnitalSubsemiring.map_eq_comap] using NonUnitalSubsemiring.map_le_iff_le_comap"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa only [NonUnitalSubsemiring.le_def] using NonUnitalSubsemiring.map_le_iff_le_comap"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa only [\u2190 NonUnitalSubsemiring.le_comap_iff] using NonUnitalSubsemiring.map_le_iff_le_comap"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa only [\u2190 SetLike.coe_subset_coe] using (NonUnitalSubsemiring.map_le_iff_le_comap (R := R) (S := S)).Iff.symm"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa only [\u2190 NonUnitalSubsemiring.coe_toSubsemigroup] using (NonUnitalSubsemiring.map_le_iff_le_comap f).Iff.symm"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa only [\u2190 NonUnitalSubsemiring.coe_to_subsemigroup] using (NonUnitalSubsemiring.map_le_iff_le_comap f)"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "rw [NonUnitalSubsemiring.map_le_iff_le_comap, NonUnitalSubsemiring.comap_comap]"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa only [\u2190 SetLike.coe_subset_coe] using (NonUnitalSubsemiring.map_le_iff_le_comap f).Iff.symm"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa [\u2190 NonUnitalSubsemiring.coe_to_subsemigroup f] using NonUnitalSubsemiring.map_le_iff_le_comap"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa using (NonUnitalSubsemiring.map_le_iff_le_comap s).Iff.symm"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa using (NonUnitalSubsemiring.map_le_iff_le_comap f)"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa only [\u2190 NonUnitalSubsemiring.coe_toSubsemigroup, NonUnitalSubsemiring.map_comap] using NonUnitalSubsemiring.map_le_iff_le_comap"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa only [\u2190 NonUnitalSubsemiring.coe_toSubsemigroup, NonUnitalSubsemiring.comap_map] using NonUnitalSubsemiring.map_le_iff_le_comap"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa [NonUnitalSubsemiring.map_eq] using NonUnitalSubsemiring.map_le_iff_le_comap"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa only [\u2190 NonUnitalSubsemiring.coe_to_subsemigroup, NonUnitalSubsemiring.map_comap] using NonUnitalSubsemiring.map_le_iff_le_comap"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "rw [NonUnitalSubsemiring.map_le_iff_le_comap, NonUnitalSubsemiring.comap_map]"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "constructor"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa only [\u2190 NonUnitalSubsemiring.comap_map] using NonUnitalSubsemiring.map_le_iff_le_comap"}, {"state": "R : Type u\nS\u271d : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\u271d\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\u271d\ninst\u271d : NonUnitalRingHomClass G S\u271d T\ns\u271d : NonUnitalSubsemiring R\nf : F\ns : NonUnitalSubsemiring R\nS : NonUnitalSubsemiring S\u271d\n\u22a2 map f s \u2264 S \u2194 s \u2264 comap f S", "positive": "simpa only [NonUnitalSubsemiring.map_le_iff_le_comap] using NonUnitalSubsemiring.map_le_iff_le_comap", "negative": "simpa only [\u2190 NonUnitalSubsemiring.coe_toSubsemigroup] using (NonUnitalSubsemiring.map_le_iff_le_comap (R := R) (S := S)).Iff.symm"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "ext"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "ext n"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "ext i"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "erw [CauSeq.Completion.mk_mul, CauSeq.Completion.mk_eq_mk]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "erw [CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "ext x"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "exact Setoid.refl _"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "ext \u27e8i\u27e9"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "erw [CauSeq.Completion.mk_mul, CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "exact Setoid.symm (CauSeq.mul_mul_mk f g)"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "rw [\u2190 CauSeq.Completion.mk_mul, CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "simp [CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "erw [CauSeq.Completion.mk_mul f g]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "ext \u27e8i, hi\u27e9"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "rw [CauSeq.Completion.mk_mul, CauSeq.Completion.mk_eq_mk]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "rw [\u2190 CauSeq.Completion.mk_mul, CauSeq.Completion.mk_eq_mk]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "erw [\u2190 CauSeq.Completion.mk_mul, CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "erw [\u2190 CauSeq.Completion.mk_mul, CauSeq.Completion.mk_eq_mk]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "exact Setoid.symm (CauSeq.Completion.mk_mul _ _)"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "ext <;> simp"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "conv_rhs => rw [\u2190 CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "rw [CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "ext (x | x) <;> simp"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "simp"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "rw [\u2190 CauSeq.Completion.mk_mul, \u2190 CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "rw [\u2190 CauSeq.Completion.mk_eq_mk, CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "erw [CauSeq.Completion.mk_eq_mk]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "conv_lhs => rw [\u2190 CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "ext \u27e8\u27e9"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "exact congr_arg _ (CauSeq.Completion.mk_mul _ _)"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "erw [\u2190 CauSeq.Completion.mk_eq_mk, CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "ext \u27e8n\u27e9"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "rw [Setoid.rel_eq]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "exact CauSeq.Completion.mk_mul _ _"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "simp [CauSeq.Completion.mk_eq_mk]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "rw [CauSeq.Completion.mk_mul, CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "exact Setoid.symm (CauSeq.mul_mul_mk _ _ _)"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "ext \u27e8n, h\u27e9"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "convert CauSeq.Completion.mk_mul f g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "ext \u27e8x, y\u27e9"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "simp only [CauSeq.Completion.mk_eq_mk, CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "exact Setoid.symm (CauSeq.Completion.mk_mul f g)"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "ext1"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "exact Setoid.symm (CauSeq.mul_mul_mul_comm f g)"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "ext \u27e8n, hn\u27e9"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "erw [CauSeq.Completion.mk_eq_mk, CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "erw [\u2190 CauSeq.Completion.mk_mul, \u2190 CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "conv => lhs; rw [\u2190 CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "erw [\u2190 CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "exact congr_arg CauSeq.Completion.mk (CauSeq.mul_mul_mk f g)"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "exact Setoid.symm (CauSeq.mul_abv_mul _ _ _)"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "erw [CauSeq.Completion.mk_mul, CauSeq.Completion.mk_eq_mk, CauSeq.Completion.mk_eq_mk]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "rw [\u2190 CauSeq.Completion.mk_eq_mk, \u2190 CauSeq.Completion.mk_eq_mk, CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "cases CauSeq.abv f g <;> rfl"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "exact (CauSeq.Completion.mk_mul _ _).Eq.symm"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "funext i"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "simp [CauSeq.mul_def]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "change CauSeq.Completion.mk f * CauSeq.Completion.mk g = CauSeq.mk (f * g)"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "exact Setoid.symm (CauSeq.eq_mk_of_abv_mul_eq f g)"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "change CauSeq.Completion.mk f * CauSeq.Completion.mk g = CauSeq.mk (f * g) by simp"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "simp only [CauSeq.Completion.mk_eq_mk]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "ext (x | x)"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 mk f * mk g = mk (f * g)", "positive": "unfold CauSeq.Completion.mk", "negative": "exact Setoid.symm (CauSeq.mul_mul_cancel f g)"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "simp only [Quotient.eq'']"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "rw [\u2190 CauSeq.Completion.mk_mul, CauSeq.Completion.mk_eq_mk]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "rw [\u2190 CauSeq.Completion.mk_mul, CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "rw [\u2190 CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "rw [\u2190 CauSeq.Completion.mk_mul, \u2190 CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "simp only [CauSeq.Completion.mul_def]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "rw [Quotient.eq'']"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "let t := CauSeq.Completion.mk g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "let t := CauSeq.inv g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "simp only [\u2190 CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "simp only [CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "letI := CauSeq.abv abv"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "let t := CauSeq.completion abv"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "let t := CauSeq.toCompletion g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "simp only [\u2190 CauSeq.Completion.mk_mul, CauSeq.Completion.mk_eq_mk]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "let t := CauSeq.mk f"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "let t := CauSeq.toCompletion"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "rw [\u2190 Quotient.mk_eq_mk'', \u2190 CauSeq.Completion.mk_eq_mk, CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "let t := Quotient.mk'' g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "simp only [Quotient.eq]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "let t := CauSeq.Completion.mk (f * g)"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "let s := CauSeq.Completion.mk f"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "simp_rw [\u2190 CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "rw [\u2190 CauSeq.Completion.mk_mul, CauSeq.Completion.mk_eq_mk'']"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "rw [\u2190 CauSeq.Completion.mk_eq_mk, \u2190 CauSeq.Completion.mk_eq_mk, CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "simp only [\u2190 CauSeq.Completion.mk_eq_mk, CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "rw [\u2190 Quotient.eq'']"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "simp only [CauSeq.Completion.mul_mk]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "rw [\u2190 CauSeq.Completion.mk_mul, CauSeq.Completion.mk_eq_mk, CauSeq.Completion.mk_eq_mk]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "rw [\u2190 CauSeq.Completion.mk_eq_mk, CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "rcases eq_or_ne g 0 with (rfl | hg)"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "let t := CauSeq.abv abv"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "simp only [\u2190 Quotient.eq'']"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "letI := CauSeq.toCompletion"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "rw [\u2190 Quotient.mk_eq_mk'', CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "let t := Quotient.mk'' f"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "rw [\u2190 CauSeq.Completion.mk_mul, mul_comm]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "let t := CauSeq.mk g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "revert g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "let s := CauSeq.mk f"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "rw [\u2190 CauSeq.Completion.mk_mul, CauSeq.Completion.mk_eq_mk, CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "rw [\u2190 CauSeq.Completion.mk_mul, CauSeq.Completion.mul_mk]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "rcases eq_or_ne f g with (rfl | hg)"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "let t := CauSeq.inv f * CauSeq.Completion.mk g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "simp_rw [\u2190 CauSeq.Completion.mk_eq_mk, CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "rw [\u2190 CauSeq.Completion.mk_mul, CauSeq.Completion.mk_eq_mk_iff]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "rw [\u2190 Quotient.mk_eq_mk, \u2190 CauSeq.Completion.mk_eq_mk, CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "let t := CauSeq.Completion.completion g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "rw [\u2190 Quotient.mk''_eq_mk, \u2190 CauSeq.Completion.mk_mul, CauSeq.Completion.mk_eq_mk]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "let t := CauSeq.completion g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "let t := CauSeq.mk (f * g)"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "let nonempty := CauSeq.abv abv"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "simp only [CauSeq.Completion.mul_mk'']"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "simp_rw [\u2190 CauSeq.Completion.mk_mul, CauSeq.Completion.mk_eq_mk]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "rw [\u2190 Quotient.mk''_eq_mk, CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "rw [Quotient.eq'', CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "rw [\u2190 Quotient.mk''_mul, CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "let t := CauSeq.toCompletion (CauSeq.Completion.mk f)"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "simp only [CauSeq.Completion.mul_eq_mk]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "let t := CauSeq.completionTrivial abv"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "rw [\u2190 Quotient.mk''_eq_mk, \u2190 CauSeq.Completion.mk_mul]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "let t := CauSeq.Completion.mk f * CauSeq.Completion.mk g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "let t := CauSeq.Completion.mk f", "negative": "let t := CauSeq.toCompletion (CauSeq.Completion.mk g)"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "set t' := CauSeq.Completion.mk f"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let t' := CauSeq.Completion.mk f"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let \u27e8t', t'\u27e9 := Quotient.exact t"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "set t' := CauSeq.Completion.mk g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "set t' := Quotient.mk'' g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let t' := CauSeq.Completion.mk g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let t' := Quotient.mk'' g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let t' := CauSeq.mk g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let q := CauSeq.Completion.mk f"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let \u27e8t', t'\u27e9 := Quotient.exists_rep t"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let \u27e8l, hl\u27e9 := Quotient.exact t"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "set q := CauSeq.Completion.mk f"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "rw [Quotient.eq'']"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let d := CauSeq.Completion.mk f"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let t' := CauSeq.mk f"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let \u27e8l, hl\u27e9 := Quotient.exists_rep t"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "set t' := CauSeq.mk g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let t' := CauSeq.inv t"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let q := CauSeq.Completion.mk g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "set t' := CauSeq.inv t"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let c := CauSeq.Completion.mk f"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let h := CauSeq.Completion.mk f"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "set q := CauSeq.Completion.mk g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let ht := CauSeq.Completion.mk f"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "simp only [Quotient.eq'']"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let t' := CauSeq.Completion.inv t"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let \u27e8t', ht'\u27e9 := Quotient.exact t"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let h := Quotient.mk'' g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let o := CauSeq.Completion.mk f"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "set t' := CauSeq.Completion.inv t"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let c := Quotient.mk'' g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "set t' := CauSeq.mk f"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let \u27e8t', t'\u27e9 := Quotient.exact t'"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let q := Quotient.mk'' g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let \u27e8cs, ts\u27e9 := Quotient.exact t"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let h := Quotient.mk_out' g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "have t' := Quotient.sound \u27e8t, rfl\u27e9"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let ht := Quotient.mk'' g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let d := CauSeq.Completion.mk g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let t' := Quotient.mk g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "set t' := Quotient.mk g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "rw [\u2190 Quotient.eq'']"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "have ht : t = CauSeq.Completion.mk g := rfl"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "have : t = CauSeq.Completion.mk g := rfl"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let d := Quotient.mk'' g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let h := CauSeq.Completion.mk_inv g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "have : t = CauSeq.Completion.mk f * t := rfl"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let c := Quotient.mk'' (f * g)"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "exact Quotient.sound \u27e8t, rfl\u27e9"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "set t' := CauSeq.const abv g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let data := Quotient.mk'' g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let ht := CauSeq.Completion.ext t"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let h := CauSeq.Completion.ext t"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "simp only [CauSeq.Completion.mul_mk]"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "set t' := CauSeq.Completion.Completion.mk f"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let t' := CauSeq.Completion.Completion.mk f"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "have t' : t = CauSeq.Completion.mk g := rfl"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "set q := Quotient.mk'' g"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let \u27e8u, hu\u27e9 := Quotient.exact t"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let \u27e8l, hl\u27e9 := Quotient.exact hl"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let t' := CauSeq.Completion.ext t"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let \u27e8t', t'\u27e9 := Quotient.exact' t"}, {"state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nt : Cauchy abv := mk f\n\u22a2 Quotient.mk'' f * Quotient.mk'' g = Quotient.mk'' (f * g)", "positive": "congr 1", "negative": "let o := CauSeq.Completion.mk g"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "rw [\u2190 b.total_repr]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "simp only [Basis.repr_symm_apply, Basis.repr_total]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "simp only [Basis.coord_apply, Basis.repr_symm_apply, Finsupp.total_apply]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "simp [Basis.repr_symm_apply, Finsupp.total_apply]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "simp only [Basis.repr_symm_apply, Basis.repr_total, Finsupp.total_apply]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "simp only [Basis.repr_symm_apply, Basis.coord_apply, Finsupp.total_apply]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "simp [Basis.coord_apply, Finsupp.total_apply]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "simp only [Basis.coord_apply, Basis.repr_symm_apply, Finsupp.total_apply, Finsupp.sum]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "rw [Basis.repr_symm_apply, Basis.repr_total]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "rw [\u2190 b.total_repr f, b.total_repr]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "simp only [Basis.repr_symm_apply, Basis.coord_apply, Finsupp.total_apply, Finsupp.sum]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "simp only [Basis.repr_symm_apply, Basis.total_repr]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "rw [Basis.repr_symm_apply, b.repr.apply_symm_apply, Finsupp.total_apply]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "rw [Basis.repr_symm_apply, Basis.total_repr]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "rw [b.repr_symm_apply, Basis.repr_total]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "simp only [Basis.coord_apply, Basis.repr_symm_apply]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "rw [\u2190 b.coord_apply_single i f]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "rw [Basis.repr_symm_apply, Basis.coord_apply, Finsupp.total_apply]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "simp only [Basis.repr_symm_apply, Basis.coord_apply, LinearEquiv.map_zero]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "simp only [Basis.coord_apply, Basis.repr_symm_apply, Finsupp.total_apply, Basis.repr_total]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "rw [Basis.repr_symm_apply, Basis.coord_apply, Finsupp.total_apply, Finsupp.sum]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "rw [\u2190 b.coord_apply_combination, b.repr.apply_symm_apply]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "rw [Basis.repr_symm_apply, b.repr.apply_symm_apply]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "simp only [Basis.coord_apply, Basis.repr_symm_apply, Finsupp.total_apply, Finsupp.sum_single_index]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "simp only [Basis.repr_symm_apply, Finsupp.total_apply, Basis.repr_total]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "simp [Basis.coord_apply, Finsupp.total_apply, Finsupp.sum]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "rw [b.coord_apply, Basis.repr_symm_apply, Finsupp.total_apply]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "rw [Basis.repr_symm_apply, b.repr.apply_symm_apply, Finsupp.total_apply, Finsupp.sum]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "simp only [Basis.repr_symm_apply, b.repr.apply_symm_apply, Finsupp.total_apply]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "rw [\u2190 b.total_repr, Basis.total_repr]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "simp only [Basis.repr_symm_apply, Basis.coord_apply, Finsupp.total_apply, Basis.repr_total]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "simp only [Basis.repr_symm_apply, Basis.total_repr, Finsupp.total_apply]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "simp [Basis.coord_apply, Basis.repr_symm_apply, Finsupp.total_apply]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "rw [\u2190 b.repr.injective.eq_iff]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "simp [Basis.coord_apply, Finsupp.total]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "rw [\u2190 b.total_repr, Basis.repr_total]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "simp only [Basis.repr_symm_apply, Basis.coord_apply]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "rw [Basis.repr_symm_apply, b.total_repr]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "rw [Basis.coord_apply, Basis.repr_symm_apply, Finsupp.total_apply]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "simp only [Basis.repr_symm_apply, Basis.coord_apply, Finsupp.total_apply, Finsupp.sum_single_index]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "simp only [Basis.repr_symm_apply, b.repr.apply_symm_apply, Basis.repr_total]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "simp only [Basis.repr_symm_apply, Basis.coord_apply, LinearEquiv.map_zero, Finsupp.zero_apply]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "rw [\u2190 b.total_repr f, Basis.repr_total]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "rw [\u2190 b.total_repr f, Basis.total_repr]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "simp only [Basis.repr_symm_apply, Basis.coord_apply, Basis.repr_total, Finsupp.total_apply]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "rw [\u2190 b.total_repr f, b.repr_symm_single, Finsupp.total_apply]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "rw [Basis.coord_apply, Basis.repr_symm_apply, Finsupp.total_apply, Finsupp.sum]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "simp [Basis.repr_symm_apply, Finsupp.total_apply, Finsupp.sum]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "simp only [Basis.coord_apply, Basis.repr_symm_apply, Finsupp.total_apply, b.repr.apply_symm_apply]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "simp only [Basis.coord_apply, Basis.repr_total, Finsupp.total_apply]"}, {"state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb\u271d b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191(coord b i) (\u2191(LinearEquiv.symm b.repr) f) = \u2191f i", "positive": "simp [Basis.coord_apply]", "negative": "simp only [Basis.repr_symm_apply, b.repr.apply_symm_apply, Finsupp.total_apply, Finsupp.sum]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "rcases Set.eq_empty_or_nonempty s with (rfl | \u27e8x, hx\u27e9)"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8t, ht\u27e9 := s.eq_empty_or_nonempty"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "rcases Set.eq_empty_or_nonempty s with (rfl | hs)"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8t, -, -\u27e9 := Set.eq_empty_or_nonempty s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8x, hx\u27e9 := s.eq_empty_or_nonempty"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8x, hx\u27e9 := Set.eq_empty_or_nonempty s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8u, -, -, -\u27e9 := Set.eq_empty_or_nonempty s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "rcases Set.eq_empty_or_nonempty s with rfl|hs"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8t, ht\u27e9 := Set.eq_empty_or_nonempty s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8t, hst\u27e9 := s.eq_empty_or_nonempty"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "by_contra H"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "rcases Set.eq_empty_or_nonempty s with (rfl | hne)"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8x, hx\u27e9 : \u2203 x, x \u2208 s := Set.eq_empty_or_nonempty s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "rcases Set.eq_empty_or_nonempty s with (rfl | h)"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "rcases s.eq_empty_or_nonempty with (rfl | \u27e8x, hx\u27e9)"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8u, -, -, -, h\u27e9 := Set.eq_empty_or_nonempty s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8u, -, -, hu\u27e9 := Set.eq_empty_or_nonempty s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8u, -, -\u27e9 := Set.eq_empty_or_nonempty s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8t, -, -\u27e9 := s.eq_empty_or_nonempty"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8t, -, -, -\u27e9 := Set.eq_empty_or_nonempty s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8t, -, -, h\u27e9 := Set.eq_empty_or_nonempty s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8t, _\u27e9 := s.eq_empty_or_nonempty"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8u, _\u27e9 := s.eq_empty_or_nonempty"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8t, _, _\u27e9 := s.eq_empty_or_nonempty"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "rcases s.eq_empty_or_nonempty with (rfl | hs)"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8u, hu\u27e9 := s.eq_empty_or_nonempty"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8u, _, _\u27e9 := s.eq_empty_or_nonempty"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8u, -, -, hus\u27e9 := Set.eq_empty_or_nonempty s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8t, hst\u27e9 := Set.eq_empty_or_nonempty s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8t, -, ht\u27e9 := Set.eq_empty_or_nonempty s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8t, ht\u27e9 := exists_surjective_nat s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8x, hx\u27e9 := exists_surjective_nat s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8u, -, -, h\u27e9 := Set.eq_empty_or_nonempty s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8u, hsub\u27e9 := s.eq_empty_or_nonempty"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8u, -, -, sub\u27e9 := Set.eq_empty_or_nonempty s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8u, -, -, -, -\u27e9 := Set.eq_empty_or_nonempty s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8x, -, hx\u27e9 := Set.eq_empty_or_nonempty s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8u, -, -, hu\u27e9 := s.eq_empty_or_nonempty"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8u, hsub\u27e9 := Set.eq_empty_or_nonempty s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8t, -, -, rfl\u27e9 := Set.eq_empty_or_nonempty s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8t, ht\u27e9 := exists_subset_nonempty s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8t, -, ht\u27e9 := s.eq_empty_or_nonempty"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8u, -, sub\u27e9 := Set.eq_empty_or_nonempty s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8u, _, u_meas\u27e9 := Set.eq_empty_or_nonempty s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8t, _, _\u27e9 := Set.eq_empty_or_nonempty s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "rcases s.eq_empty_or_nonempty with (rfl | h)"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "rcases Set.eq_empty_or_nonempty s with rfl|s_ne"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "rcases Set.eq_empty_or_nonempty s with (rfl | _)"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8u, -, -, -, hu\u27e9 := Set.eq_empty_or_nonempty s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "rcases Set.eq_empty_or_nonempty s with (rfl | h\u2080)"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8u, -, -, u_meas\u27e9 := Set.eq_empty_or_nonempty s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "rcases eq_or_ne s \u22a5 with (rfl | hs)"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8x, hx\u27e9 : \u2203 x, x \u2208 s := exists_subset_nonempty s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8u, -, -, -, -, h\u27e9 := Set.eq_empty_or_nonempty s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8t, -, -\u27e9 := Set.nonempty_iff_ne_empty.2 s.Nonempty"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "refine' \u27e8MeasurableSpace.generateFrom _\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8u, hsub\u27e9 := exists_subset_nonempty s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "rcases Set.eq_empty_or_nonempty s with (h | h)"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "rcases Set.eq_empty_or_nonempty s with rfl|\u27e8x, hx\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "rcases eq_or_ne s \u22a5 with rfl | h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8x, hx\u27e9 : \u2203 x, s \u2286 t \u2227 MeasurableSet t := exists_subset_nonempty s"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "rcases Set.eq_empty_or_nonempty s with (rfl | \u27e8x, h\u27e9)"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "by_contra h", "negative": "obtain \u27e8u, -, -, -\u27e9 := Set.nonempty_iff_ne_empty.2 s.Nonempty"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Set.not_nonempty_iff_eq_empty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty, Set.Nonempty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty.intro, MeasurableSet] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simpa [Set.not_nonempty_iff_eq_empty] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty.intro] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty.intro h] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Set.not_nonempty_iff_eq_empty.1 h] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Set.Nonempty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty, Set.not_nonempty_iff_eq_empty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simpa [Set.Nonempty] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty.some] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty.intro, h] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simpa [\u2190 Set.not_nonempty_iff_eq_empty] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simpa [Nonempty] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty.def, Set.not_nonempty_iff_eq_empty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [\u2190 Set.not_nonempty_iff_eq_empty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [h] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simpa using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp_rw [Set.not_nonempty_iff_eq_empty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Set.not_nonempty_iff_eq_empty.2 h] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty, MeasurableSet] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty.default] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty.some, h] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty.def, Set.Nonempty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Set.not_nonempty_iff_eq_empty, Set.Nonempty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Set.not_nonempty_iff_eq_empty, Set.not_nonempty_iff_eq_empty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty.intro, Set.not_nonempty_empty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty.mk] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty.def, \u2190 Set.not_nonempty_iff_eq_empty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty, \u2190 Set.not_nonempty_iff_eq_empty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty.intro, MeasurableSet, h] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty, Set.not_nonempty_empty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Set.not_nonempty_iff_eq_empty, MeasurableSet] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp only [Set.not_nonempty_iff_eq_empty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simpa [\u2190 Set.Nonempty] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty.intro, Set.not_nonempty_iff_eq_empty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Set.not_nonempty_iff_eq_empty, Nonempty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty, -Set.not_nonempty_iff_eq_empty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty.def] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty, h] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty, Nonempty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simpa [Nonempty.intro] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp_rw [\u2190 Set.not_nonempty_iff_eq_empty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty, -Set.Nonempty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp_rw [Nonempty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty.intro, Set.Nonempty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty.def, MeasurableSet] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simpa [Set.nonempty_iff_ne_empty] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Set.not_nonempty_iff_eq_empty, Set.not_nonempty_empty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp_rw [Nonempty.intro, Set.not_nonempty_iff_eq_empty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty.intro, Set.not_nonempty_iff_eq_empty.1 h] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [-Set.not_nonempty_iff_eq_empty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Set.not_nonempty_iff_eq_empty, h] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty, (Set.nonempty_iff_ne_empty _).2 h] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp_rw [not_nonempty_iff] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty, Ne.def] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty.def, Set.not_nonempty_empty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [MeasurableSet] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp_rw [Nonempty, Set.not_nonempty_iff_eq_empty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Nonempty.not_nonempty_iff_eq_empty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 False", "positive": "apply h", "negative": "simp [Set.nonempty_iff_ne_empty] at h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa [Set.nonempty_iff_ne_empty] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa [Set.not_nonempty_iff_eq_empty] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa [Set.Nonempty] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa [Set.nonempty_iff_ne_empty]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa [\u2190 Set.nonempty_coe_sort] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa [\u2190 Set.nonempty_iff_ne_empty] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa [\u2190 Set.nonempty_iff_ne_empty]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "exact \u27e8\u27e8fun _ => s, fun _ => h\u27e9\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa [Set.nonempty_coe_sort] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa [\u2190 Set.not_nonempty_iff_eq_empty] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa only [Set.nonempty_iff_ne_empty] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "exact \u27e8\u27e8fun _ => s, fun _ => s, fun _ => h\u27e9\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa only [Set.nonempty_coe_sort] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "exact \u27e8\u27e8fun _ => Set.empty_subset _\u27e9\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa only [Set.nonempty_coe_sort, Set.not_nonempty_iff_eq_empty] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa [\u2190 Set.nonempty_coe_sort]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa [Set.not_nonempty_iff_eq_empty]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "exact MeasurableSpace.measurableSet_generateFrom h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa only [Set.Nonempty] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "exact Nonempty.intro s h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa [\u2190 Set.nonempty_coe_sort, Classical.not_not] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa only [Set.not_nonempty_iff_eq_empty] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa [Set.Nonempty]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa [\u2190 Set.not_nonempty_iff_eq_empty]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "exact Classical.not_not.1 h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "exact \u27e8\u27e8fun _ => s, fun _ => MeasurableSet.empty\u27e9\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "exact \u27e8\u27e8fun _ => MeasurableSet.empty, fun _ => h\u27e9\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa only [Set.nonempty_iff_ne_empty]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "exact \u27e8\u27e8fun _ => s, fun _ => Set.empty_subset _\u27e9\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa only [Set.Nonempty, Set.empty_subset] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "exact MeasurableSet.nonempty"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "exact (Set.not_nonempty_iff_eq_empty.1 h).1"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa [Set.nonempty_coe_sort]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa [Set.nonempty_coe_sort, h] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa [Set.nonempty_coe_sort, Set.not_nonempty_iff_eq_empty] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa only [\u2190 Set.not_nonempty_iff_eq_empty] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa [Set.nonempty_def] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "exact \u27e8\u27e8fun _ => s, fun _ => Set.subset_sUnion_of_mem\u27e9\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa [\u2190Set.nonempty_iff_ne_empty] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "exact Set.nonempty_subset.1 h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "exact \u27e8\u27e8fun _ => s, fun _ => s, fun _ => MeasurableSet.empty\u27e9\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "exact \u27e8\u27e8fun _ => s, fun _ => s, h\u27e9\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa [\u2190 Set.nonempty_coe_sort, Set.nonempty_coe_sort] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "exact \u27e8\u27e8fun _ => Set.empty_subset _, fun _ => h\u27e9\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa [Set.Nonempty, h] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa [Set.nonempty_iff_ne_empty.2 h] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "exact \u27e8\u27e8fun _ \u21a6 Set.empty_subset _\u27e9\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "exact \u27e8\u27e8fun _ => s, fun _ => s, fun _ => Set.subset_sUnion_of_mem\u27e9\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "exact h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa [Set.nonempty_iff_ne_empty, h] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa only [\u2190 Set.nonempty_coe_sort] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "exact \u27e8\u27e8fun _ => Set.empty_subset s\u27e9, fun _ => h\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "exact Set.nonempty_of_nonempty_inter h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "exact \u27e8\u27e8fun _ => Set.empty_subset _\u27e9, fun _ => h\u27e9"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa only [Set.nonempty_coe_sort, Set.not_nonempty_iff_eq_empty]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "exact (Set.not_nonempty_iff_eq_empty.1 h).Eq.symm"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa only [Set.nonempty_coe_sort]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa [\u2190Set.nonempty_coe_sort] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa [h] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "simpa only [Set.nonempty_coe_sort, Set.nonempty_coe_sort] using h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nh : \u00acNonempty { t // s \u2286 t \u2227 MeasurableSet t }\n\u22a2 Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "positive": "measurability", "negative": "exact \u27e8\u27e8fun _ => s, fun _ => h, fun _ => h\u27e9\u27e9"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.lastFun_eq]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.lastFun]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.lastFun, TypeVec.lastFun_toSubtype]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.lastFun, TypeVec.lastFun]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp only [TypeVec.lastFun, TypeVec.lastFun_subtypeVal]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "rw [\u2190 TypeVec.lastFun_toSubtype p]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.dropFun, TypeVec.lastFun]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.lastFun_eq, *]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "rw [\u2190 TypeVec.lastFun_of_subtype p]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.lastFun_eq_lastFun]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.lastFun, *]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.dropFun_eq]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp only [TypeVec.lastFun_subtypeVal]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "rw [\u2190 TypeVec.lastFun_from_append1_drop_last, TypeVec.lastFun_toSubtype]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.lastFun, TypeVec.lastFun_from_append1_drop_last]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp only [TypeVec.lastFun_eq, TypeVec.lastFun_subtypeVal]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.lastFun_eq_dropFun]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.lastFun_eq, TypeVec.lastFun_toSubtype]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.lastFun_def]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp only [TypeVec.lastFun, TypeVec.lastFun_toSubtype, TypeVec.lastFun_subtypeVal]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.lastFun, TypeVec.lastFun_subtypeVal]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.lastFun_eq_dropFun, *]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp only [TypeVec.lastFun_eq, TypeVec.lastFun_toSubtype]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp only [TypeVec.lastFun, TypeVec.lastFun_toSubtype]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.lastFun_subtypeVal]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.lastFun, TypeVec.lastFun_toSubtype, TypeVec.lastFun_subtypeVal]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp only [TypeVec.lastFun_eq_lastFun, TypeVec.lastFun_toSubtype]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp only [TypeVec.lastFun, TypeVec.lastFun_toSubtype, id_eq]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.lastFun, TypeVec.lastFun, *]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "rw [\u2190 TypeVec.lastFun_from_append1_drop_last]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.lastFun, TypeVec.lastFun_eq]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp only [TypeVec.lastFun_eq, TypeVec.lastFun_toSubtype, id_eq]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "rw [\u2190 TypeVec.lastFun_toSubtype p, TypeVec.lastFun_toSubtypeVal]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.lastFun, -TypeVec.lastFun_toSubtype]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "rw [\u2190 TypeVec.lastFun_toSubtype p, TypeVec.lastFun_subtypeVal]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp only [\u2190 TypeVec.lastFun_from_append1_drop_last, TypeVec.lastFun_toSubtype]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "rw [\u2190 TypeVec.dropFun_lastFun, TypeVec.lastFun_toSubtype]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.dropFun, TypeVec.lastFun, *]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp only [TypeVec.lastFun, TypeVec.lastFun_from_append1_drop_last, TypeVec.lastFun_toSubtype]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp only [TypeVec.lastFun, TypeVec.lastFun_subtypeVal, id_eq]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.dropFun_eq, *]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "rw [\u2190 TypeVec.lastFun_id p]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "rw [TypeVec.lastFun_eq]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp only [TypeVec.lastFun_subtypeVal, id_eq]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp only [TypeVec.lastFun, TypeVec.lastFun_toSubtype, id_eq, TypeVec.lastFun_subtypeVal]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.dropFun, TypeVec.dropFun, *]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simpa using TypeVec.lastFun_toSubtype p"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.lastFun, TypeVec.lastFun_of_subtype]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.lastFun_eq_lastFun, *]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.lastFun, TypeVec.lastFun_toSubtype, TypeVec.lastFun]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.lastFun, TypeVec.lastFun, TypeVec.lastFun_toSubtype]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.lastFun, TypeVec.lastFun_toSubtypeVal]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.dropFun, TypeVec.lastFun, TypeVec.lastFun]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp only [TypeVec.lastFun_subtypeVal, TypeVec.lastFun_toSubtype]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.dropFun, TypeVec.dropFun]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.eq_of_drop_last_eq (TypeVec.dropFun_lastFun p)]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.lastFun_eq, TypeVec.lastFun]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp only [\u2190 TypeVec.lastFun_toSubtype p, TypeVec.lastFun_subtypeVal]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.dropFun_eq, TypeVec.lastFun]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.subtypeVal]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp [TypeVec.lastFun, TypeVec.dropFun]"}, {"state": "n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\n\u22a2 lastFun (subtypeVal p) = Subtype.val", "positive": "ext i : 2", "negative": "simp only [TypeVec.lastFun_eq, TypeVec.lastFun_toSubtype, TypeVec.lastFun_subtypeVal]"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp [TypeVec.lastFun_subtypeVal]"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp [TypeVec.lastFun, *]"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp [TypeVec.lastFun]"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> dsimp [TypeVec.lastFun, *] <;> rfl"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp [TypeVec.lastFun_subtypeVal, *] <;> rfl"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp [TypeVec.lastFun_subtypeVal, *]"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction' i with i ih"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> dsimp [TypeVec.lastFun, TypeVec.lastFun, *] <;> rfl"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp [*]"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp [TypeVec.lastFun_subtypeVal] <;> rfl"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction' i with i _ i_ih"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction' i with i _"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction' i with _ _ i_ih"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> dsimp [TypeVec.lastFun, TypeVec.lastFun] at *"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> dsimp [TypeVec.lastFun]"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction' i with i _ ih"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp [TypeVec.lastFun, *, TypeVec.lastFun]"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp [TypeVec.lastFun_of_subtype_last, *]"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp [TypeVec.lastFun_appendFun]"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp [TypeVec.last_dropFun, *] <;> rfl"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp [-TypeVec.lastFun_subtypeVal]"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp [TypeVec.lastFun_of_subtype, *]"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> dsimp [TypeVec.lastFun, TypeVec.lastFun]"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp only [TypeVec.lastFun_subtypeVal, *] <;> rfl"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction' i with i _ _ i_ih"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> dsimp only [TypeVec.lastFun, TypeVec.lastFun] at *"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction' i with _ _ _ i_ih"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp_all"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp [Function.comp]"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp [-TypeVec.lastFun_subtypeVal, *]"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp [-TypeVec.lastFun_subtypeVal, *] <;> rfl"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp [TypeVec.lastFun_appendFun, *]"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp [TypeVec.lastFun_of_subtype, *] <;> rfl"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp [TypeVec.lastFun_of_subtype_last, *] <;> rfl"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp [TypeVec.lastFun_of_subtype]"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp only [TypeVec.lastFun_subtypeVal] <;> rfl"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> dsimp only [TypeVec.lastFun, TypeVec.lastFun, *] <;> rfl"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> induction i <;> simp [TypeVec.lastFun, *] <;> rfl"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp [TypeVec.lastFun_of_subtype_last]"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp [TypeVec.lastFun, *, TypeVec.lastFun_subtypeVal]"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp [TypeVec.lastFun, *] at *"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp [TypeVec.lastFun_cons]"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp [TypeVec.lastFun_cons, *] <;> rfl"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp only [TypeVec.lastFun_subtypeVal]"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> dsimp only [TypeVec.lastFun, TypeVec.lastFun_subtypeVal] at *"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> [rfl; simp only [TypeVec.lastFun_subtypeVal]]"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> dsimp only [TypeVec.lastFun, TypeVec.lastFun, TypeVec.lastFun] at *"}, {"state": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\np : \u03b1 \u27f9 repeat (n + 1) Prop\ni : last (Subtype_ p)\n\u22a2 lastFun (subtypeVal p) i = \u2191i", "positive": "induction i <;> simp [TypeVec.lastFun, *] <;> rfl", "negative": "induction i <;> simp [*, TypeVec.lastFun_subtypeVal]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel'_right]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_diff hA hB h, add_sub_cancel']"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_diff hA hB h, add_sub_cancel'_right]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_diff (hA.diff hA) (hB.diff hA) h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_diff hA hB h, MeasureTheory.VectorMeasure.of_add_of_diff hA hB h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 v.of_diff hA hB h, MeasureTheory.VectorMeasure.of_diff hA hB h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, MeasureTheory.VectorMeasure.of_add_of_diff hA hB h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_diff hA hB h, sub_self]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_diff hA hB h, MeasureTheory.VectorMeasure.of_diff hA hB h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_diff (hA.diff hA) (hB.diff hB) h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "exact MeasureTheory.VectorMeasure.of_diff hA hB h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 v.of_diff hA hB h, add_sub_cancel'_right]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 v.of_diff hA hB h, MeasureTheory.VectorMeasure.of_add_of_diff hA hB h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [MeasureTheory.VectorMeasure.of_diff hA hB h, sub_self]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_diff hA hB h, Set.union_diff_cancel h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "apply MeasureTheory.VectorMeasure.of_diff hA hB h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_zero]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_diff hA hB h, MeasureTheory.VectorMeasure.of_add hA hB h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "apply MeasureTheory.VectorMeasure.of_diff _ hA hB h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_diff (hA.diff hA) hB h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, sub_add_cancel]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [MeasureTheory.VectorMeasure.of_diff hA hB h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff (hA.diff hA) (hB.diff hA) h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [MeasureTheory.VectorMeasure.of_diff hA hB h, sub_sub]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_comm]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_diff (hA.diff hB) (hB.diff hA) h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_union v hA hB h, add_sub_cancel']"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "exact v.of_diff hA hB h"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 v.of_diff hA hB h, add_sub_cancel']"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_union v hA hB h, MeasureTheory.VectorMeasure.of_union v hA hB h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_tsub_cancel_of_le]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_diff hA hB h, MeasureTheory.VectorMeasure.of_add_of_diff hA hA h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_union v hA hB h, add_sub_cancel'_right]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_diff hA hB h, Set.union_diff_self]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 v.of_diff hA hB h, MeasureTheory.VectorMeasure.of_add hA hB h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_diff hA hB h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, MeasureTheory.VectorMeasure.of_diff hA hB h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 v.of_diff hA hB h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_diff (hA.diff hB) hA h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_diff hA hB h, sub_add_cancel]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [MeasureTheory.VectorMeasure.of_diff hA hB h, tsub_self]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [v.of_diff hA hB h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_diff v hA hB h, add_sub_cancel']"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_diff hA hB h, tsub_self]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "symm"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_diff hA hB h, Set.diff_union_of_subset h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_diff hA hB h, MeasureTheory.VectorMeasure.of_diff (hA.diff hA) (hB.diff hB) h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 Set.diff_union_of_subset h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, MeasureTheory.VectorMeasure.of_add_of_diff hA hA h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_diff (hA.diff hA) (hB.diff h) h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [MeasureTheory.VectorMeasure.of_diff hA hB h, add_sub_cancel']"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_diff hA hB h, add_sub_cancel]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_diff hA hB h, add_comm]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_union v hA hB h, Set.union_diff_cancel h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, Set.union_diff_cancel h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_diff v hA hB h, add_sub_cancel'_right]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_diff hA (hA.diff hB) h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, MeasureTheory.VectorMeasure.of_add_of_diff (hA.diff hA) (hB.diff hB) h]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 add_zero (v (B \\ A))]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [MeasureTheory.VectorMeasure.of_diff hA hB h, add_sub_cancel'_right]"}, {"state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM\u271d : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : T2Space M\u271d\nv\u271d : VectorMeasure \u03b1 M\u271d\nf : \u2115 \u2192 Set \u03b1\nM : Type u_4\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : T2Space M\nv : VectorMeasure \u03b1 M\nA B : Set \u03b1\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : A \u2286 B\n\u22a2 \u2191v (B \\ A) = \u2191v B - \u2191v A", "positive": "rw [\u2190 MeasureTheory.VectorMeasure.of_add_of_diff hA hB h, add_sub_cancel']", "negative": "rw [\u2190 MeasureTheory.VectorMeasure.of_diff (hA.diff hB) hA hB, add_sub_cancel'_right]"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def, mul_one] using SubfieldClass.coe_rat_mem s a"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def] using SubfieldClass.coe_rat_mem s a"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [mul_one] using SubfieldClass.coe_rat_mem s a"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [smul_eq_mul] using SubfieldClass.coe_rat_mem s a"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [one_mul] using SubfieldClass.coe_rat_mem s a"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def, mul_comm] using SubfieldClass.coe_rat_mem s a"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [smul_eq_mul] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (coe_int_mem a x.prop) (SubfieldClass.coe_rat_mem s a)"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [mul_comm] using SubfieldClass.coe_rat_mem s a"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def] using MulMemClass.mul_mem SubfieldClass.coe_rat_mem s a"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def, div_eq_mul_inv] using SubfieldClass.coe_rat_mem s a"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "rw [Rat.smul_def]"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa using SubfieldClass.coe_rat_mem s a"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def] using s.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def, one_mul] using SubfieldClass.coe_rat_mem s a"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def, mul_one] using SubfieldClass.coe_int_mem s a"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def] using SubfieldClass.coe_int_mem s a"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def, Rat.cast_mul] using SubfieldClass.coe_rat_mem s a"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "convert SubfieldClass.coe_rat_mem s a"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [mul_one] using SubfieldClass.smul_mem s a x.prop"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def, coe_nat_mul] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) (SubfieldClass.coe_rat_mem s x)"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def, coe_nat_mul] using SubfieldClass.coe_rat_mem s a"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def] using (SubfieldClass.coe_rat_mem s a).Eq.symm"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def] using SubfieldClass.mul_mem s a.prop (a \u2022 x)"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def, smul_eq_mul] using SubfieldClass.coe_rat_mem s a"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa using SubfieldClass.smul_mem s a x.prop"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def, MulAction.mul_smul] using SubfieldClass.coe_rat_mem s a"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [one_mul] using SubfieldClass.smul_mem s a x.prop"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def] using coe_int_mem s a"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [mul_comm] using SubfieldClass.smul_mem s a x.prop"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def] using coe_int_mem a x"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [\u2190 Rat.smul_def] using SubfieldClass.coe_rat_mem s a"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def] using SubfieldClass.mul_mem s a.prop (SubfieldClass.coe_rat_mem s a)"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [smul_eq_mul, mul_one] using SubfieldClass.coe_rat_mem s a"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (coe_int_mem a x.2) (SubfieldClass.coe_rat_mem s a)"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) (coe_int_mem a x)"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def, mul_one] using SubfieldClass.coe_mem s a"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def, mul_one] using s.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "convert SubfieldClass.smul_mem s a x.prop"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def] using (coe_int_mem a x).Eq.symm"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def] using MulMemClass.smul_mem (SubfieldClass.coe_rat_mem s a) x.prop"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [SubfieldClass.coe_rat_mem] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def, mul_one] using MulMemClass.mul_mem SubfieldClass.coe_rat_mem s a"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (coe_int_mem a x) (SubfieldClass.coe_rat_mem s a)"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [mul_one] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (coe_int_mem a x.2) (coe_nat_mem s a)"}, {"state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Field M\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\na : \u211a\nx : { x // x \u2208 s }\n\u22a2 a \u2022 \u2191x \u2208 s", "positive": "simpa only [Rat.smul_def] using MulMemClass.mul_mem (SubfieldClass.coe_rat_mem s a) x.prop", "negative": "simpa only [Rat.smul_def] using SubfieldClass.smul_mem s a x.prop"}]}